<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>角色卡工作室 (多功能版)</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<style>
:root {
    /* --- 颜色方案 (深色主题) --- */
    --bg-color: #121212;
    --panel-color: #1e1e1e;
    --panel-secondary-color: #2a2a2a;
    --text-color: #e0e0e0;
    --text-secondary-color: #AAAAAA;
    --border-color: #3a3a3a;
    --primary-color: #FFFFFF; 
    
    /* 功能色 */
    --danger-color: #e57373;
    --success-color: #81c784;
    --warning-color: #ffd54f;
    --info-color: #64b5f6;
}

/* =========================================
   1. 全局排版与字体 (INS 风)
   ========================================= */
body { 
    font-family: "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", Arial, sans-serif;
    background-color: var(--bg-color); 
    color: var(--text-color); 
    margin: 0;
    padding: 0; 
    transition: background-color 0.3s, color 0.3s;
    letter-spacing: 0.02em; 
    -webkit-font-smoothing: antialiased;
}

.container { max-width: 1200px; margin: 0 auto; }

/* 标题排版优化 - 紧凑型 */
h1, h2, h3 { 
    text-align: center; 
    margin-left: auto; 
    margin-right: auto;
}

h1 { 
    font-weight: 700; 
    color: var(--primary-color);
    font-size: 1.6em; 
    margin-top: 5px;  
    margin-bottom: 12px; 
    letter-spacing: 0.05em; 
}

h2 { color: var(--text-color); margin-bottom: 10px; }
h3 { margin-top: 0; color: var(--text-secondary-color); font-weight: 600; font-size: 1em; }

/* 页面内边距调整 */
#page-library, #page-dashboard {
    padding: 10px 15px 100px 15px; 
    box-sizing: border-box;
}

/* =========================================
   2. 通用组件 (头部、搜索、导航)
   ========================================= */
/* 头部操作栏 */
.page-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
}
.page-header h1 {
    margin: 0;
    text-align: left;
    font-size: 1.8em;
}
.header-actions {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}
.header-action-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--border-color);
    background-color: var(--panel-color);
    color: var(--text-secondary-color);
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: background-color 0.2s, color 0.2s;
}
.header-action-btn:hover {
    background-color: var(--panel-secondary-color);
    color: var(--primary-color);
}
.header-action-btn svg { width: 22px; height: 22px; }

/* 搜索框 */
.search-container {
    position: relative;
    display: flex;
    align-items: center;
    flex-grow: 1;
}
.search-icon {
    position: absolute;
    left: 15px;
    width: 18px;
    height: 18px;
    color: var(--text-secondary-color);
    pointer-events: none;
}
#search-input {
    width: 100%;
    height: 44px;
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    border-radius: 22px;
    color: var(--text-color);
    font-size: 1em;
    padding: 0 20px 0 45px;
    box-sizing: border-box;
    transition: border-color 0.2s, background-color 0.2s;
}
#search-input:focus {
    outline: none;
    border-color: var(--primary-color);
    background-color: var(--panel-secondary-color);
}
#search-input::-webkit-search-cancel-button { -webkit-appearance: none; appearance: none; }

/* 底部导航栏 */
#bottom-nav {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 20px;
    width: 90%;          
    max-width: 380px;    
    height: 60px;        
    border-radius: 30px; 
    background-color: rgba(30, 30, 30, 0.85); 
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--border-color);
    display: flex;
    z-index: 99;
    box-shadow: 0 5px 20px rgba(0,0,0,0.3);
}
.nav-item { 
    flex: 1; 
    display: flex; 
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    text-decoration: none; 
    color: var(--text-secondary-color); 
    transition: all 0.2s; 
}
.nav-item.active { 
    color: var(--primary-color); 
    transform: translateY(-2px);
}
.nav-item svg { width: 24px; height: 24px; margin-bottom: 3px; }
.nav-item span { font-size: 10px; font-weight: 500; }

/* =========================================
   3. 弹窗系统 (高级磨砂玻璃风)
   ========================================= */
.modal-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.7);
    z-index: 100;
    display: flex; justify-content: center; align-items: center;
    opacity: 0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.modal-overlay.active { opacity: 1; visibility: visible; }

/* 统一弹窗容器 */
.modal-content, .glass-modal-content {
    background: rgba(20, 20, 20, 0.6) !important; /* 透出背景 */
    backdrop-filter: blur(30px) !important;
    -webkit-backdrop-filter: blur(30px) !important;
    border: 1px solid rgba(255, 255, 255, 0.12) !important;
    border-radius: 24px !important;
    box-shadow: 0 25px 50px rgba(0,0,0,0.5) !important;
    width: 80% !important; 
    max-width: 300px !important;
    height: auto !important;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    padding: 0 !important;
    overflow: hidden;
    animation: popIn 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
}
@keyframes popIn {
    from { opacity: 0; transform: scale(0.9); }
    to { opacity: 1; transform: scale(1); }
}

/* 弹窗头部 */
.modal-header {
    border-bottom: none !important;
    padding: 20px 20px 5px 20px !important;
    justify-content: center !important;
    position: relative;
}
.modal-header h3 {
    font-size: 1.1em !important;
    font-weight: 600;
    color: var(--text-color);
    text-align: center;
}
.modal-close { display: none !important; }

/* 弹窗内容 */
.modal-body {
    padding: 10px 20px 20px 20px !important;
    text-align: center;
    font-size: 0.95em;
    color: var(--text-secondary-color);
    overflow-y: auto;
}

/* 弹窗底部按钮区 */
.modal-footer {
    border-top: none !important;
    padding: 0 20px 20px 20px !important;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* 弹窗内按钮通用样式 (胶囊化) */
.modal-footer button, 
.modal-body button,
#folder-options-modal button {
    width: 100% !important;
    max-width: 100% !important;
    padding: 12px 0 !important;
    border-radius: 30px !important;
    font-size: 0.95em !important;
    font-weight: 500;
    border: none !important;
    cursor: pointer;
    transition: transform 0.1s, background-color 0.2s;
    margin: 0 !important;
    
    /* 默认：深色半透明玻璃 */
    background: rgba(0, 0, 0, 0.2) !important;
    border: 1px solid rgba(255, 255, 255, 0.05) !important;
    color: var(--text-secondary-color) !important;
    backdrop-filter: blur(10px);
}
.modal-footer button:active, .modal-body button:active {
    transform: scale(0.96);
    background: rgba(255, 255, 255, 0.1) !important;
    color: var(--text-color) !important;
}

/* 取消按钮 (通常是最后一个) */
.modal-footer button:last-child {
    margin-top: 5px !important;
    background: rgba(255, 255, 255, 0.05) !important;
}

/* 危险操作按钮 */
.btn-delete-char, .btn-delete-selected, .btn-danger, #btn-opt-delete {
    background-color: rgba(229, 115, 115, 0.2) !important;
    color: var(--danger-color) !important;
}

/* 文件夹管理弹窗特殊布局 */
#folder-options-modal .modal-body {
    display: flex !important;
    flex-direction: column;
    gap: 10px !important;
    padding: 25px 20px !important;
}

/* 目标文件夹列表 (选择展示内容/移动) */
.target-folder-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    max-height: 200px;
    overflow-y: auto;
    justify-content: center;
    padding: 5px 0 15px 0;
}

/* 胶囊按钮 (双层磨砂) */
.capsule-btn {
    padding: 10px 18px !important;
    font-size: 0.9em !important;
    background: rgba(255, 255, 255, 0.03) !important; /* 暗淡玻璃 */
    border: 1px solid rgba(255, 255, 255, 0.08) !important;
    color: var(--text-secondary-color) !important;
    border-radius: 30px !important;
    transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
}
.capsule-btn.highlight {
    background: rgba(255, 255, 255, 0.15) !important; /* 发光玻璃 */
    color: #FFFFFF !important;
    font-weight: 600 !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    box-shadow: inset 0 0 10px rgba(255, 255, 255, 0.05), 0 4px 15px rgba(0, 0, 0, 0.2) !important;
    backdrop-filter: blur(5px); 
    transform: scale(1.05);
}

/* 前后位置选择器 (iOS 分段控制器风格) */
.position-selector {
    display: flex;
    justify-content: space-between;
    background: rgba(0, 0, 0, 0.4) !important; /* 凹槽 */
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 16px !important;
    padding: 4px !important;
    margin: 20px 10px 10px 10px !important;
}
.position-option {
    flex: 1;
    text-align: center;
    padding: 10px 0 !important;
    border-radius: 12px !important;
    cursor: pointer;
    font-size: 0.95em;
    color: var(--text-secondary-color);
    transition: all 0.3s;
    border: 1px solid transparent;
}
.position-option.selected {
    background: rgba(255, 255, 255, 0.15) !important; /* 悬浮滑块 */
    color: #FFFFFF !important;
    font-weight: 600;
    border-color: rgba(255, 255, 255, 0.2) !important;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
}

/* 确认移动弹窗文字优化 */
#reorder-confirm-modal p {
    line-height: 1.8 !important;
    color: var(--text-secondary-color);
    margin-bottom: 5px !important;
}
#reorder-confirm-modal strong {
    color: var(--text-color);
    font-size: 1.1em;
    padding: 0 4px;
}

/* --- 紧凑型弹窗优化样式 (Final Version) --- */

/* 1. 容器：缩小整体尺寸 */
#reorder-confirm-modal .glass-modal-content {
    width: 70% !important;           /* 宽度变窄，更精致 */
    max-width: 260px !important;     /* 限制最大宽度 */
    padding: 25px 20px 20px 20px !important; /* 内边距缩小 */
    display: flex;
    flex-direction: column;
    gap: 0 !important;               /* 清除默认间隙，手动控制 */
}

/* 2. 文字区域：紧凑排版 */
#reorder-confirm-modal h3 {
    font-size: 1.05em !important;
    margin-bottom: 8px !important;   /* 标题与正文距离拉近 */
}
#reorder-confirm-modal p {
    font-size: 0.9em !important;
    margin-bottom: 12px !important;  /* 正文与选择器距离拉近 */
    line-height: 1.4 !important;     /* 行高稍微紧凑一点 */
}

/* 3. 前后选择器：变薄、变小 */
#reorder-confirm-modal .position-selector {
    margin: 0 0 15px 0 !important;   /* 上下边距大幅缩小 */
    padding: 3px !important;         /* 槽位变细 */
    border-radius: 12px !important;
}
#reorder-confirm-modal .position-option {
    padding: 6px 0 !important;       /* 选项高度变矮 */
    font-size: 0.85em !important;
    border-radius: 9px !important;
}

/* 4. 确定按钮：精致小巧的深色玻璃 */
#btn-confirm-move {
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05)) !important;
    border: 1px solid rgba(255, 255, 255, 0.25) !important;
    color: #FFFFFF !important;
    font-weight: 600 !important;
    border-radius: 20px !important;  /* 圆角适配小按钮 */
    
    /* 尺寸调整 */
    margin-top: 5px !important;      /* 紧贴上方元素 */
    margin-bottom: 8px !important;   /* 与取消按钮的间距 */
    padding: 10px 0 !important;      /* 按钮高度变矮 */
    font-size: 0.9em !important;     /* 字体微调 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3) !important;
}

/* 5. 取消按钮：紧凑化 */
#reorder-confirm-modal .capsule-btn:last-child {
    padding: 8px 0 !important;       /* 按钮变矮 */
    font-size: 0.85em !important;
    margin-top: 0 !important;
    border: none !important;         /* 取消按钮去掉边框，显得更轻 */
    background: transparent !important; /* 背景透明 */
    opacity: 0.7;
}

/* =========================================
   4. 资料库 (卡片堆叠与文件夹)
   ========================================= */
/* 文件夹导航栏 */
.folder-scroll-container {
    display: flex;
    overflow-x: auto;
    gap: 10px;
    padding: 5px 5px 15px 5px;
    margin-bottom: 10px;
    scrollbar-width: none; 
    -ms-overflow-style: none;
}
.folder-scroll-container::-webkit-scrollbar { display: none; }
.folder-chip {
    padding: 6px 16px;
    border-radius: 20px;
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    font-size: 0.9em;
    white-space: nowrap;
    cursor: pointer;
    transition: all 0.2s;
    user-select: none;
}
.folder-chip.active {
    background-color: var(--primary-color);
    color: var(--bg-color);
    border-color: var(--primary-color);
    font-weight: 600;
}
.folder-chip.add-btn {
    color: var(--primary-color);
    border-style: dashed;
}

/* 卡片堆叠 */
#card-stack-container { position: relative; width: 100%; max-width: 350px; height: 450px; margin: 30px auto; perspective: 1000px; }
#card-stack-container .card-thumb {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    border-radius: 24px;
    box-shadow: 0 15px 30px rgba(0,0,0,0.3);
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    will-change: transform, opacity;
    transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: grab;
    display: flex; flex-direction: column; overflow: hidden;
    transform: translateZ(0);
}
.card-thumb .card-image-wrapper { flex-grow: 1; background-color: var(--panel-secondary-color); }
.card-thumb img { width: 100%; height: 100%; object-fit: cover; }
.card-thumb .json-icon { font-size: 4em; color: var(--text-secondary-color); display: flex; align-items: center; justify-content: center; height: 100%; }
.card-thumb .name-bar {
    background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
    color: white;
    padding: 25px 15px 15px 15px;
    text-align: left;
    font-weight: 600;
    font-size: 1.2em;
    position: absolute; bottom: 0; width: 100%; box-sizing: border-box;
}
#card-stack-container .card-thumb.current { transform: translateY(0) scale(1); opacity: 1; z-index: 3; pointer-events: auto; }
#card-stack-container .card-thumb.next { transform: translateY(25px) scale(0.95); opacity: 1; z-index: 2; pointer-events: none; }
#card-stack-container .card-thumb.after-next { transform: translateY(50px) scale(0.9); opacity: 1; z-index: 1; pointer-events: none; }
#card-stack-container .card-thumb:not(.current):not(.next):not(.after-next) { opacity: 0; pointer-events: none; transform: translateY(75px) scale(0.85); }
#card-stack-container .card-thumb.dismiss-left { transform: translateX(-200%) rotate(-30deg) !important; opacity: 0 !important; }
#card-stack-container .card-thumb.dismiss-right { transform: translateX(200%) rotate(30deg) !important; opacity: 0 !important; }

/* 堆叠操作按钮 */
#stack-actions { display: flex; justify-content: center; gap: 30px; margin-top: 20px; }
#stack-actions button { 
    width: 70px; height: 70px; border-radius: 50%; 
    border: 1px solid var(--border-color); background-color: var(--panel-color); 
    font-size: 2.5em; cursor: pointer; 
    box-shadow: 0 4px 15px rgba(0,0,0,0.1); transition: transform 0.2s; 
    display: flex; justify-content: center; align-items: center; padding: 0;
}
#stack-actions button:hover { transform: scale(1.1); }
#btn-nope { color: var(--danger-color); }
#btn-like { color: var(--success-color); }

/* =========================================
   5. 仪表盘 (Dashboard)
   ========================================= */
.dashboard-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 15px; 
    margin-top: 5px;
}
.dashboard-panel {
    background-color: var(--panel-color);
    border: 1px solid var(--border-color); 
    border-radius: 20px; 
    padding: 18px; 
    box-shadow: 0 4px 20px rgba(0,0,0,0.2); 
    margin-bottom: 0; 
}
.dashboard-panel h3 {
    text-align: left;
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.05em;
    display: flex;
    align-items: center;
    gap: 6px;
}

/* 精选收藏画廊 */
.fav-scroll-view {
    display: flex;
    overflow-x: auto;
    padding: 20px;
    gap: 15px;
    scrollbar-width: none; 
    min-height: 160px;
    align-items: center;
}
.fav-scroll-view::-webkit-scrollbar { display: none; }
.fav-card-item {
    flex-shrink: 0;
    width: 95px;  
    height: 135px; 
    border-radius: 16px; 
    overflow: hidden;
    position: relative;
    border: 1px solid var(--border-color);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    transition: transform 0.2s;
    cursor: pointer;
}
.fav-card-item:hover { transform: translateY(-5px); }
.fav-card-item img { width: 100%; height: 100%; object-fit: cover; }
.fav-card-name {
    position: absolute; bottom: 0; left: 0; width: 100%;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
    color: white; 
    font-size: 0.75em; 
    padding: 20px 5px 8px 5px; 
    text-align: center; 
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis;
    font-weight: 500;
    letter-spacing: 0.03em;
}
.empty-state-text { width: 100%; text-align: center; color: var(--text-secondary-color); font-size: 0.9em; padding: 20px 0; }

/* --- 紧凑版仪表盘样式 (库存档案 & 数据维护) --- */

/* --- 库存档案：横向滚动模式 (无限文件夹也不占地) --- */

.folder-stats-container { 
    display: flex !important;        /* 改为弹性布局 */
    overflow-x: auto !important;     /* 开启横向滚动 */
    gap: 10px !important;            /* 间距 */
    margin-top: 10px !important;
    padding-bottom: 5px !important;  /* 稍微留点底部空间防止误触 */
    
    /* 隐藏丑陋的滚动条 */
    scrollbar-width: none !important; /* Firefox */
    -ms-overflow-style: none !important; /* IE/Edge */
}
.folder-stats-container::-webkit-scrollbar { 
    display: none !important; /* Chrome/Safari */
}

.folder-stat-chip {
    flex: 0 0 88px !important;       /* 【关键】固定宽度，不许压缩 */
    height: 60px !important;         /* 固定高度 */
    
    /* 样式美化 */
    padding: 0 5px !important;
    border-radius: 14px !important;
    background-color: rgba(255, 255, 255, 0.03) !important;
    border: 1px solid var(--border-color) !important;
    color: var(--text-secondary-color) !important;
    
    /* 内容垂直居中 */
    display: flex !important; 
    flex-direction: column !important; 
    align-items: center !important; 
    justify-content: center !important;
    transition: background 0.2s !important; 
}

/* 选中高亮样式 (如果有) */
.folder-stat-chip[data-folder="我的最爱"] {
    border-color: rgba(255, 100, 100, 0.3) !important;
    background: linear-gradient(to bottom, rgba(255, 100, 100, 0.08), rgba(255, 100, 100, 0.02)) !important;
}

/* 字体调整 */
.folder-stat-count { 
    font-weight: 700 !important; 
    color: var(--primary-color) !important; 
    font-size: 1.2em !important; 
    margin-bottom: 3px !important;
}
.folder-stat-name { 
    font-size: 0.75em !important; 
    font-weight: 500 !important;
    opacity: 0.7 !important;
    
    /* 防止名字太长换行 */
    white-space: nowrap !important; 
    overflow: hidden !important; 
    text-overflow: ellipsis !important; 
    max-width: 100% !important;
}
.folder-stat-count { 
    font-weight: 700; 
    color: var(--primary-color); 
    font-size: 1.1em; 
    margin-bottom: 2px;
}
.folder-stat-name { 
    font-size: 0.75em; 
    font-weight: 500;
    opacity: 0.7;
    white-space: nowrap; 
    overflow: hidden; 
    text-overflow: ellipsis; 
    max-width: 100%;
}
.folder-stat-chip[data-folder="我的最爱"] {
    border-color: rgba(255, 100, 100, 0.3);
    background-color: rgba(255, 100, 100, 0.05);
}

/* 2. 数据维护：单行并排按钮 */
.toolbox-buttons-grid { 
    display: flex; /* 弹性布局，一行排列 */
    gap: 8px; 
}
.tool-btn {
    flex: 1; /* 三个按钮平分宽度 */
    background-color: rgba(255, 255, 255, 0.03);
    border: 1px solid var(--border-color);
    color: var(--text-color);
    padding: 12px 0;
    border-radius: 12px;
    cursor: pointer;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    font-size: 0.8em; 
    transition: background 0.2s;
}
.tool-btn:hover { background-color: var(--border-color); }

.tool-btn .icon { 
    width: 20px; 
    height: 20px; 
    margin-bottom: 4px; 
    color: var(--primary-color); 
}

/* 清空按钮样式特殊处理 */
.btn-danger-full {
    background-color: rgba(229, 115, 115, 0.1);
    border-color: rgba(229, 115, 115, 0.3);
    color: var(--danger-color);
    /* 保持和其他按钮一样的垂直布局 */
    flex-direction: column; 
}
.btn-danger-full .icon { 
    color: var(--danger-color); 
    margin-bottom: 4px; 
    margin-right: 0; 
}
.btn-danger-full:hover { background-color: rgba(229, 115, 115, 0.2); }

/* 加载动画 */
.loading-placeholder {
    display: flex; justify-content: center; align-items: center; height: 100px;
    color: var(--text-secondary-color); font-size: 0.9em;
    background: rgba(255,255,255,0.02); border-radius: 12px;
}
.loading-placeholder::after { content: "数据加载中..."; animation: pulse 1.5s infinite; }
@keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

/* =========================================
   6. 详情页 & 附件页
   ========================================= */
.detail-view-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 150;
    display: flex; align-items: flex-end;
    opacity: 0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.detail-view-overlay.active { opacity: 1; visibility: visible; }
.detail-view-overlay.active .detail-view-content { transform: translateY(0); }
.detail-view-content {
    width: 100%; height: 90vh;
    background-color: var(--panel-color);
    border-top-left-radius: 24px; border-top-right-radius: 24px;
    box-sizing: border-box;
    display: flex; flex-direction: column;
    transform: translateY(100%);
    padding: 10px 0 20px 0; 
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
}
.pull-handle {
    width: 40px; height: 5px;
    background-color: var(--border-color);
    border-radius: 2.5px;
    margin: 0 auto 10px auto; flex-shrink: 0;
}
.detail-header { display: flex; align-items: center; margin-bottom: 15px; padding: 0 20px; flex-shrink: 0; }
#detail-avatar { width: 44px; height: 44px; border-radius: 50%; object-fit: cover; background-color: var(--panel-secondary-color); }
.header-text { flex-grow: 1; margin-left: 12px; }
.header-text p { margin: 2px 0 0 0; font-size: 0.8em; color: var(--text-secondary-color); }
#detail-close-btn { font-size: 1.8rem; background: none; border: none; color: var(--text-secondary-color); cursor: pointer; }
.detail-scroll-container { flex-grow: 1; padding: 0 20px; display: flex; flex-direction: column; min-height: 0; overflow-y: auto; }
.detail-main-image {
    width: 100%; aspect-ratio: 5 / 6;
    border-radius: 16px; overflow: hidden;
    background-color: var(--panel-secondary-color);
    margin: 0 0 20px 0; flex-shrink: 0;
}
#detail-image { width: 100%; height: 100%; object-fit: cover; cursor: zoom-in; }
#detail-description {
    background-color: var(--panel-secondary-color);
    border-radius: 16px; padding: 15px;
    white-space: pre-wrap; word-wrap: break-word;
    font-size: 1em; line-height: 1.6;
    color: var(--text-secondary-color);
    margin: 0; overflow-y: auto; max-height: 200px; flex-shrink: 0;
}
.detail-footer {
    display: flex; gap: 20px;
    padding: 15px 20px 0 20px;
    border-top: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    flex-shrink: 0; margin-top: auto;
}

/* 详情页菜单 */
.detail-actions-container { position: relative; margin-left: auto; margin-right: 10px; }
#detail-more-btn { width: 36px; height: 36px; }
.action-menu {
    display: none; position: absolute; top: 100%; right: 0;
    margin-top: 8px; width: 150px; z-index: 10; overflow: hidden;
    background-color: var(--panel-secondary-color);
    border-radius: 8px; border: 1px solid var(--border-color);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
}
.action-menu.active { display: block; }
.action-menu-item {
    display: block; width: 100%; padding: 12px 15px;
    background: none; border: none;
    color: var(--text-color); text-align: left;
    font-size: 0.9em; cursor: pointer;
}
.action-menu-item:hover { background-color: var(--border-color); }
.action-menu-item.danger { color: var(--danger-color); }

/* 附件页 */
#page-attachments { background-color: var(--bg-color); padding: 0 0 100px 0; box-sizing: border-box; height: 100vh; overflow-y: auto; }
.detail-section { margin-top: 15px; flex-shrink: 0; }
.detail-section-header { display: flex; justify-content: space-between; align-items: center; border-radius: 16px; transition: background-color 0.2s; }
#attachments-summary-section .detail-section-header:hover { background-color: var(--border-color); }
.detail-section-header h3 { margin: 0; text-align: left; font-size: 1.1em; color: var(--text-color); }
.badge {
    display: inline-block; min-width: 20px; padding: 2px 6px;
    font-size: 0.8em; font-weight: bold; line-height: 1;
    color: var(--bg-color); text-align: center; white-space: nowrap; vertical-align: middle;
    background-color: var(--text-secondary-color); border-radius: 10px; margin-left: 8px;
}
#attachments-detail-list { list-style: none; padding: 0; margin: 20px 0 0 0; }
#attachments-detail-list li {
    display: flex; align-items: center; padding: 15px;
    background-color: var(--panel-color);
    border: 1px solid var(--border-color);
    border-radius: 12px; margin-bottom: 12px;
    transition: background-color 0.2s;
}
#attachments-detail-list li:hover { background-color: var(--panel-secondary-color); }
.attachment-icon {
    flex-shrink: 0; width: 40px; height: 40px; margin-right: 15px;
    display: flex; align-items: center; justify-content: center;
    background-color: var(--panel-secondary-color); border-radius: 8px;
}
.attachment-icon svg { width: 24px; height: 24px; color: var(--text-secondary-color); }
.attachment-info { flex-grow: 1; overflow: hidden; cursor: pointer; }
.attachment-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; color: var(--text-color); }
.attachment-meta { font-size: 0.8em; color: var(--text-secondary-color); margin-top: 4px; }
.delete-attachment-btn {
    background: none; border: none; color: var(--text-secondary-color);
    cursor: pointer; font-size: 1.5em; line-height: 1; padding: 8px;
    margin-left: 10px; border-radius: 50%; flex-shrink: 0;
    transition: color 0.2s, background-color 0.2s;
}
.delete-attachment-btn:hover { color: var(--danger-color); background-color: rgba(229, 115, 115, 0.1); }
.empty-attachments-placeholder { text-align: center; padding: 50px 20px; color: var(--text-secondary-color); }
.empty-attachments-placeholder svg { width: 50px; height: 50px; margin-bottom: 15px; opacity: 0.5; }

/* =========================================
   7. 笔记页 (Notes)
   ========================================= */
   #btn-new-note {
        background-color: var(--primary-color); 
        color: var(--bg-color); 
        font-size: 1.5em; 
        line-height: 30px; 
        cursor: pointer; 
   }
#note-list li .note-title-preview { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#note-list li .note-content-preview { font-size: 0.85em; color: var(--text-secondary-color); margin-top: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#note-list li.active .note-content-preview { color: rgba(0,0,0, 0.7); }
#editor-header h3 { margin: 0; text-align: left; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
#btn-back-to-list { display: none; border: none; background: none; font-size: 1.5em; font-weight: bold; color: var(--primary-color); margin-right: 15px; cursor: pointer; }
#btn-delete-note { background-color: var(--danger-color); color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer; }
.new-note-header { background-color: var(--panel-secondary-color); border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; }
.new-note-header h2 { margin: 0; font-size: 1.1em; }
.new-note-header button { background: none; border: none; color: var(--primary-color); font-size: 1em; cursor: pointer; }
#new-note-title-input { color: var(--text-color); border: none; border-bottom: 1px solid var(--border-color); background: transparent; font-size: 1.8em; font-weight: bold; padding: 20px 0 10px 0; margin-bottom: 15px; box-sizing: border-box; width: 100%; }
#new-note-title-input:focus { outline: none; }
#new-note-content-textarea { color: var(--text-color); background: transparent; width: 100%; height: 60vh; border: none; padding: 10px 0; font-size: 1em; line-height: 1.7; box-sizing: border-box; resize: none; }
#new-note-content-textarea:focus { outline: none; }
@media (max-width: 768px) {
    .notes-layout { display: block; height: 100vh; }
    #note-list-panel { display: flex; flex-direction: column; width: 100%; height: 100%; }
    #note-editor-panel { display: none; }
    .notes-layout.editing-mode #note-list-panel { display: none; }
    .notes-layout.editing-mode #note-editor-panel { display: flex; width: 100%; height: 100%; }
    #btn-back-to-list { display: block; }
}

/* =========================================
   8. 抽卡页面 (Gacha)
   ========================================= */
#page-gacha {
    height: 100vh; overflow: hidden; display: none;
    flex-direction: column; align-items: center; justify-content: center;
    padding-bottom: 80px; box-sizing: border-box;
}
#page-gacha.active { display: flex; }
.gacha-stage {
    position: relative; width: 85vw; max-width: 420px; height: 65vh; max-height: 650px;
    perspective: 1000px; margin-bottom: 30px; z-index: 10;
}
.gacha-card-wrapper {
    width: 100%; height: 100%; position: relative;
    transform-style: preserve-3d; transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: pointer;
}
.gacha-card-wrapper.shaking { animation: gacha-shake 0.5s ease-in-out infinite; }
.gacha-card-wrapper.flipped { transform: rotateY(180deg); }
.gacha-face {
    position: absolute; width: 100%; height: 100%; backface-visibility: hidden;
    border-radius: 20px; box-shadow: 0 25px 50px rgba(0,0,0,0.6);
    overflow: hidden; border: 1px solid var(--border-color);
}
.gacha-back {
    background: var(--panel-color);
    background-image: 
        radial-gradient(circle at 50% 50%, #2a2a2a 0%, #121212 100%),
        repeating-linear-gradient(45deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 10px, transparent 10px, transparent 20px);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    z-index: 2; border: 2px solid var(--border-color);
}
.gacha-back::after {
    content: "?"; font-size: 10em; font-weight: 800;
    color: var(--text-secondary-color); opacity: 0.1;
}
.gacha-logo {
    font-size: 1.8em; color: var(--primary-color); margin-top: 20px;
    font-weight: bold; letter-spacing: 4px; text-transform: uppercase;
    text-shadow: 0 0 10px rgba(255,255,255,0.2);
}
.gacha-front {
    transform: rotateY(180deg); background-color: #000;
    display: flex; flex-direction: column; border: none;
}
.gacha-img-container {
    width: 100%; height: 100%; position: absolute; top: 0; left: 0;
}
.gacha-img-container img { width: 100%; height: 100%; object-fit: cover; }
.gacha-info {
    position: absolute; bottom: 0; left: 0; width: 100%;
    padding: 20px 25px; box-sizing: border-box;
    background: linear-gradient(to top, rgba(0,0,0,0.4) 0%, transparent 100%);
    display: flex; flex-direction: row; justify-content: space-between; align-items: flex-end;
    z-index: 5;
}
.gacha-name {
    font-size: 1.8em; font-weight: 700; color: #fff; margin: 0; line-height: 1;
    text-shadow: 0 2px 10px rgba(0,0,0,0.9), 0 0 2px rgba(0,0,0,1);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 65%;
}
.gacha-folder {
    font-size: 0.9em; color: rgba(255,255,255,0.9);
    background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(4px);
    padding: 6px 12px; border-radius: 20px;
    border: 1px solid rgba(255,255,255,0.2);
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    white-space: nowrap; max-width: 30%; overflow: hidden; text-overflow: ellipsis;
}
.summon-btn {
    background: linear-gradient(135deg, #fff, #e0e0e0);
    color: #000; border: none; padding: 16px 60px;
    font-size: 1.1em; font-weight: 800; border-radius: 50px;
    cursor: pointer; box-shadow: 0 0 25px rgba(255, 255, 255, 0.15);
    transition: all 0.3s; z-index: 20;
    display: flex; align-items: center; gap: 8px; margin-top: 10px;
}
.summon-btn:hover { transform: scale(1.05); box-shadow: 0 0 35px rgba(255, 255, 255, 0.3); }
.summon-btn:active { transform: scale(0.95); }
.summon-btn svg { width: 20px; height: 20px; }
@keyframes gacha-shake {
    0% { transform: rotate(0deg); } 25% { transform: rotate(3deg); }
    50% { transform: rotate(0deg); } 75% { transform: rotate(-3deg); }
    100% { transform: rotate(0deg); }
}
.flash-overlay {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: white; opacity: 0; pointer-events: none; z-index: 100; transition: opacity 0.1s;
}
.flash-overlay.active { opacity: 0.9; }
.gacha-actions {
    margin-top: 25px; display: flex; gap: 20px;
    opacity: 0; transform: translateY(20px); transition: all 0.5s; pointer-events: none;
}
.gacha-actions.show { opacity: 1; transform: translateY(0); pointer-events: auto; }
.gacha-action-btn {
    background: rgba(40, 40, 40, 0.8); border: 1px solid rgba(255,255,255,0.1);
    color: #ddd; padding: 12px 24px; border-radius: 30px;
    cursor: pointer; font-size: 0.95em; backdrop-filter: blur(5px); transition: all 0.2s;
}
.gacha-action-btn:hover { background: rgba(60, 60, 60, 0.9); color: white; border-color: rgba(255,255,255,0.3); }

/* 图片查看器 */
.image-viewer-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85); z-index: 200;
    display: flex; justify-content: center; align-items: center;
    cursor: zoom-out; opacity: 0; visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.image-viewer-overlay.active { opacity: 1; visibility: visible; }
.image-viewer-overlay img { max-width: 90%; max-height: 90%; object-fit: contain; cursor: default; box-shadow: 0 0 25px rgba(0,0,0,0.5); }
.image-viewer-close { position: absolute; top: 15px; right: 25px; font-size: 2.5rem; color: white; cursor: pointer; line-height: 1; }
.page { display: none; }
.page.active { display: block; }
/* --- 详情页：气泡分离与紧凑化 (Final Fix) --- */

/* 1. 描述框 (Description) */
#detail-description {
    padding: 12px 16px !important;      /* 减小内边距，原来太厚了 */
    margin-bottom: 12px !important;     /* 【关键】增加底部间距，防止粘连 */
    border-radius: 16px !important;
    background-color: var(--panel-secondary-color) !important;
    line-height: 1.5 !important;
    font-size: 0.95em !important;
    border: 1px solid transparent !important; /* 保持边框一致性 */
}

/* 2. 文件夹选择框 (Folder Select) */
#detail-folder-select {
    width: 100% !important;
    height: 48px !important;            /* 高度减小 (56px -> 48px) */
    padding: 0 16px !important;         /* 左右内边距减小 */
    margin-bottom: 12px !important;     /* 【关键】增加底部间距 */
    border-radius: 16px !important;
    
    /* 样式重置 */
    background-color: var(--panel-secondary-color) !important;
    border: 1px solid transparent !important;
    color: var(--text-color) !important;
    font-size: 0.95em !important;
    font-weight: 500 !important;
    -webkit-appearance: none !important;
    appearance: none !important;
    outline: none !important;
    
    /* 箭头位置微调 */
    background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23AAAAAA%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
    background-repeat: no-repeat;
    background-position: right 16px center !important;
    background-size: 10px auto !important; /* 箭头也改小一点 */
}

/* 3. 附件入口 (Attachments) */
#attachments-summary-section .detail-section-header {
    width: 100% !important;
    height: 48px !important;            /* 高度减小 (56px -> 48px) */
    padding: 0 16px !important;         /* 左右内边距减小 */
    margin: 0 !important;               /* 自身不带间距 */
    
    background-color: var(--panel-secondary-color) !important;
    border-radius: 16px !important;
    border: 1px solid transparent !important;
    
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    box-sizing: border-box !important;
}

/* 隐藏原有的小标题，防止干扰布局 */
.detail-section h3 { display: none !important; }
/* 恢复附件内部的标题 */
#attachments-summary-section .detail-section-header h3 { 
    display: block !important; 
    margin: 0 !important;
    font-size: 0.95em !important;
    font-weight: 500 !important;
    color: var(--text-color) !important;
}

/* 4. 清理容器间距 */
.detail-section {
    margin: 0 !important;
    padding: 0 !important;
}
/* --- 笔记页重构：卡片式清单 (最终修复版 v3) --- */

/* 1. 页面容器与布局 */
#page-notes {
    padding-bottom: 100px !important;
    height: 100vh;
    box-sizing: border-box;
    overflow: hidden;
}

.notes-layout {
    display: flex;
    flex-direction: column;
    height: 100%;
    background-color: var(--bg-color);
}

/* 2. 列表面板 */
#note-list-panel {
    width: 100% !important;
    height: 100%;
    background-color: transparent !important;
    border: none !important;
    display: flex;
    flex-direction: column;
}

/* --- 笔记列表头部布局 (最终修复版：绝对定位) --- */

/* 1. 头部容器 */
.note-list-header {
    /* 关键：设置为相对定位，作为按钮的定位父级 */
    position: relative !important; 
    
    display: flex !important;
    align-items: center !important;
    padding: 15px 20px !important;
    width: 100%;
    box-sizing: border-box;
    border: none !important;
}

/* 2. 左侧容器 (标题和搜索框) */
.note-header-left {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%; /* 占满父容器 */
    min-width: 0;
    
    /* 关键：在右侧留出空间，防止文字跑到按钮下面 */
    /* 40px(按钮宽度) + 20px(右边距) + 12px(间隙) = 72px */
    padding-right: 72px !important;
    box-sizing: border-box;
}

/* 3. 搜索框容器 */
.note-search-container {
    position: relative;
    width: 100%;
}

/* 4. 搜索输入框 */
#note-search-input {
    width: 90%;
    height: 32px !important;
    background-color: rgba(255, 255, 255, 0.05) !important;
    border: 1px solid var(--border-color) !important;
    border-radius: 20px !important;
    padding: 0 15px 0 38px !important;
    color: var(--text-color) !important;
    font-size: 0.95em !important;
    outline: none !important;
}

/* 5. 搜索图标 */
.note-search-icon {
    position: absolute;
    left: 12px;
    top: 50%;
    transform: translateY(-50%);
    width: 18px;
    height: 18px;
    color: var(--text-secondary-color);
    pointer-events: none;
}

/* 6. 新建按钮 (绝对定位) */
#btn-new-note {
    /* 关键：使用绝对定位，脱离文档流 */
    position: absolute !important; 
    top: 50% !important;
    transform: translateY(-50%) !important;
    right: 20px !important; /* 定位到距离右侧 20px 的位置 */
    z-index: 10 !important; /* 确保在最上层 */
    
    /* 固定大小 */
    flex-shrink: 0 !important; 
    width: 35px !important;
    height: 35px !important;
    
    /* 其他样式 */
    border-radius: 12px !important;
    background-color: var(--panel-secondary-color) !important;
    border: 1px solid var(--border-color) !important;
    color: var(--primary-color) !important;
    font-size: 1.5em !important;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin: 0 !important;
}

/* 7. 媒体查询 */
@media (max-width: 768px) {
    .note-list-header h3 { display: none !important; }
}
@media (min-width: 769px) {
    .note-list-header h3 {
        display: block !important;
        font-size: 1.8em !important;
        font-weight: 700;
        color: var(--primary-color);
        margin: 0 !important;
        white-space: nowrap;
    }
    /* 桌面端，左侧容器不需要留那么多空间 */
    .note-header-left {
        width: auto;
        flex-grow: 1;
        padding-right: 0 !important;
    }
}
/* --- 头部布局修复结束 --- */


/* 3. 笔记列表容器 */
#note-list {
    list-style: none;
    padding: 10px 20px !important;
    margin: 0;
    overflow-y: auto;
    flex-grow: 1;
    scrollbar-width: none; 
}
#note-list::-webkit-scrollbar { display: none; }

/* 4. 单个笔记卡片样式 */
#note-list li {
    background-color: rgba(255, 255, 255, 0.03) !important; 
    border: 1px solid rgba(255, 255, 255, 0.08);
    border-radius: 12px !important;
    padding: 12px 16px !important;
    margin-bottom: 8px !important;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

#note-list li:active {
    background-color: rgba(255, 255, 255, 0.08) !important;
    transform: scale(0.99);
}

#note-list li .note-title-preview {
    font-size: 0.95em !important;
    font-weight: 600 !important;
    color: var(--text-color) !important;
    margin-bottom: 4px !important;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

#note-list li .note-content-preview {
    font-size: 0.8em !important;
    color: var(--text-secondary-color) !important;
    opacity: 0.7;
    line-height: 1.3 !important;
    white-space: nowrap !important; 
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 空状态美化 */
#note-list li p {
    text-align: center;
    color: var(--text-secondary-color);
    padding: 40px 0;
    font-size: 0.9em;
    background: none !important;
}
/* --- 笔记编辑器：固定头部 + 独立滚动 (修复版) --- */

/* 1. 编辑器主面板：限制高度，禁止整体滚动 */
#note-editor-panel {
    background-color: var(--bg-color) !important;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden; /* 关键：禁止整个面板被推上去 */
    box-sizing: border-box;
    padding: 0 !important; /* 去掉外层内边距，防止布局溢出 */
}

/* 2. 头部导航栏：钉死在顶部 */
#editor-header {
    padding: 15px 20px !important; /* 内边距移到这里 */
    border-bottom: 1px solid var(--border-color) !important;
    flex-shrink: 0; /* 关键：禁止头部被挤压 */
    display: flex;
    align-items: center;
    background-color: var(--bg-color); /* 确保背景不透明，防止文字重叠 */
    z-index: 10;
}

#editor-header h3 {
    font-size: 1.2em !important;
    font-weight: 600;
    margin-left: 10px;
    color: var(--text-color);
}

/* 3. 核心编辑区：填满剩余空间并独立滚动 */
#note-content-textarea {
    flex-grow: 1; /* 自动占满剩下所有高度 */
    width: 100% !important;
    height: auto !important; /* 让 flex 控制高度 */
    
    /* 样式微调 */
    background-color: transparent !important; /* 去掉背景色，与页面融合 */
    border: none !important;
    border-radius: 0 !important;
    box-shadow: none !important;
    
    /* 文字排版 */
    color: var(--text-color) !important;
    font-size: 1em !important;
    line-height: 1.6 !important;
    padding: 20px !important;
    box-sizing: border-box;
    resize: none !important;
    outline: none !important;
    
    /* 关键：开启内部滚动 */
    overflow-y: auto !important; 
}

/* 4. 底部操作栏：钉死在底部 (可选，如果不需要可以隐藏) */
#note-editor-footer {
    padding: 10px 20px !important;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0; /* 禁止被挤压 */
    background-color: var(--bg-color);
}
 /* 保存状态文字 */
#save-notes-status {
    font-size: 0.85em;
    color: var(--text-secondary-color);
    opacity: 0.7;
}

/* 删除按钮：红色幽灵按钮 */
#btn-delete-note {
    background-color: rgba(229, 115, 115, 0.1) !important;
    color: var(--danger-color) !important;
    border: 1px solid rgba(229, 115, 115, 0.3) !important;
    padding: 8px 16px !important;
    border-radius: 20px !important;
    font-size: 0.9em !important;
    cursor: pointer;
    transition: all 0.2s;
}
#btn-delete-note:active {
    background-color: rgba(229, 115, 115, 0.2) !important;
    transform: scale(0.95);
}
/* --- 修复笔记页布局：手机端单页切换 (Mobile Fix) --- */

/* 1. 桌面端默认：左右分栏 (左边列表，右边编辑) */
@media (min-width: 769px) {
    .notes-layout {
        flex-direction: row !important; /* 横向排列 */
    }
    #note-list-panel {
        width: 300px !important; /* 固定列表宽度 */
        border-right: 1px solid var(--border-color) !important;
    }
    #note-editor-panel {
        display: flex !important; /* 桌面端始终显示编辑器 */
        width: auto !important;
    }
}

/* 2. 手机端强制：单页显示 (二选一) */
@media (max-width: 768px) {
    .notes-layout {
        flex-direction: column !important;
    }

    /* 默认状态：只显示列表，隐藏编辑器 */
    #note-list-panel {
        display: flex !important;
        width: 100% !important;
        height: 100% !important;
    }
    #note-editor-panel {
        display: none !important; /* 关键：默认隐藏 */
    }

    /* 编辑状态 (点击笔记后)：隐藏列表，显示编辑器 */
    /* JS 会自动给 .notes-layout 添加 'editing-mode' 类 */
    .notes-layout.editing-mode #note-list-panel {
        display: none !important;
    }
    .notes-layout.editing-mode #note-editor-panel {
        display: flex !important;
        height: 100% !important;
        animation: slideInRight 0.3s ease; /* 加个滑入动画更顺滑 */
    }
}

/* 简单的滑入动画 */
@keyframes slideInRight {
    from { opacity: 0; transform: translateX(20px); }
    to { opacity: 1; transform: translateX(0); }
}
/* --- 笔记标题可编辑化样式 --- */

/* 改造标题输入框 */
#current-note-title-input {
    background: transparent !important;
    border: none !important;
    outline: none !important;
    
    /* 字体样式：保持像标题一样 */
    font-size: 1.3em !important;
    font-weight: 700 !important;
    color: var(--text-color) !important;
    
    /* 布局 */
    width: 100%;
    margin-left: 10px;
    padding: 5px 0;
}

/* 占位符颜色 */
#current-note-title-input::placeholder {
    color: var(--text-secondary-color);
    opacity: 0.5;
    font-weight: normal;
}
/* --- 笔记页：导入按钮样式 --- */

.header-icon-btn {
    width: 40px !important;
    height: 40px !important;
    border-radius: 12px !important;
    background-color: var(--panel-secondary-color) !important;
    border: 1px solid var(--border-color) !important;
    color: var(--text-secondary-color) !important; /* 颜色稍微淡一点区分 */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
}

.header-icon-btn svg {
    width: 20px;
    height: 20px;
}

.header-icon-btn:active {
    transform: scale(0.9);
    background-color: var(--border-color) !important;
    color: var(--text-color) !important;
}
/* 导入过滤器下拉框样式 */
.header-select-btn {
    height: 40px;
    padding: 0 10px;
    border-radius: 12px;
    background-color: var(--panel-secondary-color);
    border: 1px solid var(--border-color);
    color: var(--text-secondary-color);
    font-size: 0.85em;
    outline: none;
    cursor: pointer;
    transition: all 0.2s;
    /* 隐藏默认下拉箭头，换个好看的背景图或者简单点 */
    -webkit-appearance: none; 
    appearance: none;
    text-align: center;
    font-weight: 500;
}

.header-select-btn:hover {
    background-color: var(--border-color);
    color: var(--text-color);
}

.header-select-btn:focus {
    border-color: var(--primary-color);
}

/* 给下拉框里的选项加个深色背景，防止在某些浏览器变白 */
.header-select-btn option {
    background-color: var(--panel-color);
    color: var(--text-color);
}
/* 自定义正则输入框样式 */
.header-input {
    height: 40px;
    width: 200px; /* 稍微宽一点以便输入正则 */
    padding: 0 12px;
    border-radius: 12px;
    background-color: var(--panel-secondary-color);
    border: 1px solid var(--border-color);
    color: var(--primary-color); /*以此区分这是输入框*/
    font-size: 0.85em;
    font-family: monospace; /* 用等宽字体显示正则更清晰 */
    outline: none;
    transition: all 0.2s;
}

.header-input:focus {
    border-color: var(--primary-color);
    background-color: var(--bg-color);
    width: 240px; /* 聚焦时变宽，方便编辑 */
}

.header-input::placeholder {
    color: var(--text-secondary-color);
    opacity: 0.6;
    font-family: sans-serif;
}
/* 关联角色下拉框样式 */
#note-link-char-select {
    flex-shrink: 0;           /* 禁止被压缩 */
    max-width: 110px;         /* 限制最大宽度，防止挤占标题 */
    height: 36px;
    margin-left: 8px;
    padding: 0 5px;
    
    background-color: rgba(255, 255, 255, 0.05); /* 淡淡的背景 */
    border: 1px solid var(--border-color);
    border-radius: 10px;
    
    color: var(--primary-color);
    font-size: 0.8em;
    outline: none;
    
    /* 隐藏默认箭头，显得更简洁 */
    -webkit-appearance: none;
    appearance: none;
    text-align: center;
    text-overflow: ellipsis;
}

#note-link-char-select:disabled {
    opacity: 0.3;
}
/* =========================================
   修复：GitHub 备份弹窗专用样式
   ========================================= */

/* 1. 调整弹窗内容容器，增加宽度，减少内边距 */
#github-backup-modal .modal-content {
    width: 90% !important;
    max-width: 360px !important;
    background: rgba(30, 30, 30, 0.95) !important; /*以此保证文字清晰*/
    backdrop-filter: blur(20px) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
}

#github-backup-modal .modal-body {
    padding: 20px 20px !important; /* 减少左右内边距，让输入框宽一点 */
    text-align: left !important;
}

/* 2. 表单组样式：确保标签和输入框垂直对齐 */
.github-form-group {
    margin-bottom: 18px; /* 增加间距 */
    width: 100%;
}

/* 3. 标签样式：增加左边距，使其与输入框内的文字视觉对齐 */
.github-form-label {
    display: block;
    font-size: 0.9em;
    color: var(--text-secondary-color);
    margin-bottom: 8px;
    padding-left: 4px; /* 关键：微调左侧对齐 */
    font-weight: 500;
}

/* 4. 输入框样式优化：更清晰的背景和边框 */
.github-form-input {
    width: 100% !important;
    height: 46px !important; /* 稍微增高 */
    padding: 0 15px !important;
    box-sizing: border-box !important; /* 关键：防止输入框撑破容器 */
    
    background-color: rgba(255, 255, 255, 0.08) !important; /* 稍微亮一点的背景 */
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    border-radius: 14px !important;
    
    color: var(--text-color) !important;
    font-size: 0.95em !important;
    outline: none !important;
    transition: all 0.2s ease;
    font-family: monospace; /* 适合输入代码/Token */
}

/* 输入框聚焦效果 */
.github-form-input:focus {
    background-color: rgba(255, 255, 255, 0.12) !important;
    border-color: var(--primary-color) !important;
    box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.05);
}

/* 5. 按钮组优化 */
#github-backup-modal .modal-footer {
    display: flex !important;
    flex-direction: row !important; /* 强制横向排列 */
    gap: 12px !important;
    padding: 0 20px 25px 20px !important;
}

/* 取消按钮：透明玻璃 */
#btn-cancel-github-backup {
    flex: 1 !important;
    background: rgba(255, 255, 255, 0.05) !important;
    border: 1px solid rgba(255, 255, 255, 0.1) !important;
    color: var(--text-secondary-color) !important;
    margin: 0 !important;
}

/* 确认按钮：渐变绿，更高级 */
#btn-confirm-github-backup {
    flex: 1.5 !important; /* 让确认按钮稍微宽一点 */
    background: linear-gradient(135deg, #66bb6a, #43a047) !important; /* 渐变绿色 */
    border: none !important;
    color: #ffffff !important;
    font-weight: 600 !important;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3) !important;
    margin: 0 !important;
}
#btn-confirm-github-backup:active {
    transform: scale(0.96);
    opacity: 0.9;
}
</style>
</head>
<body>
    <!-- 页面一：资料库 -->
<div id="page-library" class="page active">
    <div class="container">
        <!-- 头部：仅包含标题 -->
        <div class="page-header">
            <h1>角色卡资料库</h1>
        </div>

        <!-- 操作栏：包含搜索和上传按钮 -->
        <div class="header-actions">
            <div class="search-container">
                <svg class="search-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 19C15.4183 19 19 15.4183 19 11C19 6.58172 15.4183 3 11 3C6.58172 3 3 6.58172 3 11C3 15.4183 6.58172 19 11 19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L16.65 16.65" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                <input type="search" id="search-input" placeholder="搜索角色卡...">
            </div>
            <button id="btn-upload" class="header-action-btn" title="上传文件">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 16.5V3M12 3L16.5 7.5M12 3L7.5 7.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 12v4.5c0 1.988-1.59 3.6-3.558 3.6H6.558C4.59 20.1 3 18.488 3 16.5V12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
            </button>
        </div>
        <!-- ===== 新增：文件夹导航栏 ===== -->
        <div class="folder-scroll-container" id="folder-nav">
        <!-- 将由JS动态生成 -->
        </div>
        <!-- 隐藏的文件输入框 (用于上传图片/JSON) -->
        <input type="file" id="file-input" multiple style="display: none;">
        <!-- ===== 新增：隐藏的 ZIP 导入输入框 (修复导入功能) ===== -->
        <input type="file" id="import-zip-input" accept=".zip" style="display: none;">
        
        <!-- 卡片堆叠区域 -->
        <div id="card-stack-container"></div>
        
        <!-- 喜欢/不喜欢按钮 -->
        <div id="stack-actions">
            <!-- 替换 ✤ 为 X 图标 -->
            <button id="btn-nope" title="不喜欢">
                <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
            </button>
            <!-- 替换 ✭ 为 心形图标 -->
            <button id="btn-like" title="喜欢">
                <svg width="30" height="30" viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"/></svg>
            </button>
        </div>

    </div> <!-- 这个是 .container 的正确闭合标签 -->
</div> <!-- 这个是 #page-library 的正确闭合标签 -->

    <!-- 页面二：仪表盘 (新版) -->
    <div id="page-dashboard" class="page">
       <div class="container">
           <h1>指挥中心</h1> <!-- 标题改得更有感觉一点 -->
        
           <div class="dashboard-grid">
            
               <!-- 1. 精选收藏画廊 (替代最近活动) -->
               <div class="dashboard-panel" style="padding: 0; overflow: hidden;">
                   <div class="panel-header" style="padding: 15px 20px; border-bottom: 1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center;">
                       <h3 id="dashboard-showcase-title" onclick="openShowcaseSelector()" style="margin:0; cursor:pointer; display:flex; align-items:center; gap:8px;">
                           💖 我的最爱 <span style="font-size:0.7em; opacity:0.5;">▼</span>
                      </h3>
                       <span style="font-size:0.8em; color:var(--text-secondary-color);">点击标题切换</span>
                  </div>
                  <div id="fav-showcase-container" class="fav-scroll-view">
                      <!-- JS 将在这里插入图片 -->
                      <div class="empty-state-text">暂无收藏，快去给角色卡点亮红心吧！</div> 
                  </div>
               </div>

               <!-- 2. 文件夹分布 (替代简单统计) -->
               <div class="dashboard-panel">
                   <h3>库存档案</h3>
                   <div id="folder-stats-grid" class="folder-stats-container">
                     <!-- JS 将在这里插入文件夹统计 -->
                  </div>
               </div>

               <!-- 3. 工具箱 (样式优化) -->
               <div class="dashboard-panel">
                  <h3>数据维护</h3>
                  <div class="toolbox-buttons-grid" style="grid-template-columns: 1fr 1fr; gap: 10px;">
                      <button id="btn-export-all" class="tool-btn">
                          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                           导出备份
                      </button>
                      <button id="btn-import-all" class="tool-btn">
                         <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                         恢复数据
                      </button>
                      <!-- 新增的 GitHub 备份按钮 -->
                      <button id="btn-backup-github" class="tool-btn">
                          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
                          云端备份
                     </button>
                     <button id="btn-clear-all" class="tool-btn btn-danger-full">
                        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                        清空所有数据
                     </button>
                  </div>
              </div>
          </div>
       </div>
    </div>

   <!-- 页面三：笔记 -->
   <div id="page-notes" class="page">
       <div class="notes-layout">
           <!-- 列表面板 -->
           <div id="note-list-panel">
               <div class="note-list-header">
                  <!-- 变化在这里：将标题和搜索框组合成一个 div -->
                  <div class="note-header-left">
                     <h3>所有笔记</h3>
                     <div class="note-search-container">
                        <svg class="note-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                        <input type="text" id="note-search-input" placeholder="搜索内容或关联角色...">
                    </div>
                 </div>

                 <!-- 变化在这里：按钮现在是 header 的直接子元素，与左侧部分并列 -->
                 <button id="btn-new-note" title="新建笔记">+</button>
              </div>
              <!-- 笔记列表容器 -->
              <ul id="note-list"></ul>
           </div>
        
           <!-- 编辑器面板 -->
           <div id="note-editor-panel">
               <div id="editor-header">
                   <button id="btn-back-to-list">&lt;</button> 
        
                   <!-- 标题输入框 -->
                   <input type="text" id="current-note-title-input" placeholder="笔记标题" disabled>
        
                   <!-- ✅ 新增：关联角色下拉框 -->
                   <select id="note-link-char-select" disabled>
                       <option value="">🔗 未关联</option>
                   </select>
               </div>
    
               <textarea id="note-content-textarea" placeholder="选择或创建一篇笔记以开始编辑..." disabled></textarea>
               <div id="note-editor-footer">
                   <span id="save-notes-status"></span>
                   <button id="btn-delete-note">删除笔记</button>
               </div>
           </div>
       </div>
  </div>

   <!-- 页面四：新建笔记 -->
    <div id="page-new-note" class="page">
        <div class="new-note-header">
            <button id="btn-cancel-new-note">取消</button>
            <h2>创建新笔记</h2>
            <button id="btn-save-new-note">保存</button>
        </div>
        <div class="container">
            <input type="text" id="new-note-title-input" placeholder="笔记标题...">
            <textarea id="new-note-content-textarea" placeholder="开始记录你的想法..."></textarea>
        </div>
    </div>
    <!-- 页面五：命运抽卡 -->
    <div id="page-gacha" class="page">
       <!-- 闪光特效层 -->
       <div id="gacha-flash" class="flash-overlay"></div>

       <div class="gacha-stage">
           <div class="gacha-card-wrapper" id="gacha-card">
               <!-- 卡背 -->
               <div class="gacha-face gacha-back">
                   <div class="gacha-logo">Character<br>Summon</div>
               </div>
               <!-- 卡面 -->
               <div class="gacha-face gacha-front">
                  <div class="gacha-img-container">
                      <img id="gacha-result-img" src="" alt="Character">
                  </div>
                  <div class="gacha-info">
                      <div id="gacha-result-name" class="gacha-name">Character Name</div>
                      <div id="gacha-result-folder" class="gacha-folder">Folder</div>
                  </div>
              </div>
          </div>
      </div>

      <button id="btn-summon" class="summon-btn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg>
          <span>开始召唤</span>
     </button>

     <div class="gacha-actions" id="gacha-actions">
         <button class="gacha-action-btn" id="btn-gacha-detail">查看详情</button>
         <button class="gacha-action-btn" id="btn-gacha-again">再抽一次</button>
     </div>
   </div>
     <!-- 附件详情页 -->
 <div id="page-attachments" class="page">
    <div class="new-note-header">
        <button id="btn-back-to-detail">返回</button>
        <h2 id="attachments-page-title">角色的附件</h2>
   </div>
   <div class="container">
       <ul id="attachments-detail-list">
       </ul>
   </div>
 </div>

 <!-- 全新的卡片详情页 -->
 <div id="card-detail-view" class="detail-view-overlay">
     <div class="detail-view-content">
         <div class="pull-handle"></div>
 
         <div class="detail-header">
             <img id="detail-avatar" src="" alt="Avatar">
             <div class="header-text">
                 <h3 id="detail-name">Character Name</h3>
                 <p id="detail-timestamp">45mins ago</p>
             </div>
             <div class="detail-actions-container">
                 <button id="detail-more-btn" class="header-action-btn">
                     <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 13C12.5523 13 13 12.5523 13 12C13 11.4477 12.5523 11 12 11C11.4477 11 11 11.4477 11 12C11 12.5523 11.4477 13 12 13Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M19 13C19.5523 13 20 12.5523 20 12C20 11.4477 19.5523 11 19 11C18.4477 11 18 11.4477 18 12C18 12.5523 18.4477 13 19 13Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 13C5.55228 13 6 12.5523 6 12C6 11.4477 5.55228 11 5 11C4.44772 11 4 11.4477 4 12C4 12.5523 4.44772 13 5 13Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
                 </button>
                 <div id="detail-action-menu" class="action-menu">
                     <!-- ===== 新增：导出角色卡按钮 ===== -->
                     <button id="btn-menu-export-card" class="action-menu-item">导出角色卡</button>
                     <button id="btn-menu-add-attachment" class="action-menu-item">添加附件</button>
                     <button id="btn-delete-character" class="action-menu-item danger">删除角色卡</button>
                 </div>
             </div>
             <button id="detail-close-btn">&times;</button>
         </div>
   
         <!-- 滚动容器 -->
         <div class="detail-scroll-container">
             <div class="detail-main-image">
                 <img id="detail-image" src="" alt="Main character image">
             </div>
             <div id="detail-description"></div>
             <!-- ===== 新增：文件夹选择区域 ===== -->
             <div class="detail-section" style="margin-top: 20px;">
                 <h3 style="text-align: left; font-size: 0.9em; margin-bottom: 5px; color:var(--text-secondary-color);">所属文件夹</h3>
                 <select id="detail-folder-select" class="detail-folder-select"></select>
             </div>
             <!-- 附件区域现在在滚动容器内部 -->
             <div id="attachments-summary-section" class="detail-section">
                <div class="detail-section-header">
                    <h3>附件 <span id="attachment-count-badge" class="badge">0</span></h3>
                    <span class="chevron-right">&gt;</span>
                </div>
             </div>
             <!-- 隐藏的附件上传输入框也放在这里 -->
             <input type="file" id="attachment-file-input" style="display: none;" multiple>
         </div>
 
         <!-- 固定底部的图标栏 -->
         <div class="detail-footer">
             <span>❤️ 4k</span>
             <span>💬 2k</span>
             <span>🔖</span>
         </div>
     </div>
 </div>
    <!-- 冲突处理弹窗 -->
    <div class="modal-overlay" id="conflict-modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header"><h3>发现同名角色卡</h3></div>
            <div class="modal-body">
                <p>资料库中已存在名为 <strong id="conflict-char-name"></strong> 的角色卡。</p>
                <p>您希望如何处理新导入的文件？</p>
            </div>
            <div class="modal-footer" style="justify-content: center;">
                <button id="btn-overwrite" class="btn-warning">覆盖更新</button>
                <button id="btn-save-as-new" class="btn-success">另存为新卡</button>
                <button id="btn-cancel-conflict" class="btn-secondary">取消操作</button>
            </div>
        </div>
    </div>

    <!-- 图片查看器 -->
    <div class="image-viewer-overlay" id="image-viewer">
        <span class="image-viewer-close">&times;</span>
        <img src="" alt="Full-size preview" id="full-preview-img">
    </div>

    <!-- 底部导航栏 (完整替换版) -->
    <nav id="bottom-nav">
        <!-- 1. 资料库 -->
        <a href="#" class="nav-item active" data-target="page-library">
           <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 4h16v16H4V4z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M9 9h6v6H9V9z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
           <span>资料库</span>
       </a>

       <!-- 2. 抽卡 (这里就是那个消失的图标) -->
       <a href="#" class="nav-item" data-target="page-gacha">
          <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" stroke-width="2"/><path d="M8 12L11 15L16 9" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          <span>抽卡</span>
      </a>

      <!-- 3. 仪表盘 -->
      <a href="#" class="nav-item" data-target="page-dashboard">
         <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M16 6h4v4h-4V6zM16 14h4v4h-4v-4zM4 14h4v4H4v-4zM4 6h4v4H4V6z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
         <span>仪表盘</span>
     </a>

     <!-- 4. 笔记 -->
     <a href="#" class="nav-item" data-target="page-notes">
        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
        <span>笔记</span>
    </a>
</nav>
    <!-- ===== 新增：文件夹操作弹窗 ===== -->
    <div class="modal-overlay" id="folder-options-modal">
        <div class="modal-content" style="max-width: 320px;">
            <div class="modal-header"><h3>管理文件夹</h3></div>
            <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px; padding: 20px;">
                <p id="folder-options-name" style="text-align:center; margin:0; font-weight:bold; color:var(--primary-color);"></p>
                <button id="btn-opt-rename" style="padding:12px; background:var(--panel-secondary-color); border:1px solid var(--border-color); color:var(--text-color); border-radius:12px; cursor:pointer; font-size:1em;">重命名</button>
                <button id="btn-opt-delete" style="padding:12px; background:rgba(229, 115, 115, 0.15); border:1px solid var(--danger-color); color:var(--danger-color); border-radius:12px; cursor:pointer; font-size:1em;">删除文件夹</button>
           </div>
           <div class="modal-footer">
              <button onclick="document.getElementById('folder-options-modal').classList.remove('active')" style="width:100%;">取消</button>
           </div>
        </div>
   </div>
   <!-- 排序：选择目标文件夹弹窗 -->
   <div class="modal-overlay" id="folder-reorder-modal">
      <div class="glass-modal-content">
          <h3 style="margin:0; font-size:1.1em;">移动 "<span id="move-source-name" style="color:var(--primary-color)"></span>" 到...</h3>
           <p style="margin:0; font-size:0.8em; color:var(--text-secondary-color); text-align:center;">选择一个目标文件夹</p>
        
           <div id="reorder-target-list" class="target-folder-list">
               <!-- JS 生成目标文件夹列表 -->
           </div>
        
           <button class="capsule-btn" style="width:100%; margin-top:10px;" onclick="document.getElementById('folder-reorder-modal').classList.remove('active')">取消</button>
      </div>
   </div>
   <!-- 仪表盘：选择展示文件夹弹窗 -->
   <div class="modal-overlay" id="showcase-selector-modal">
       <div class="glass-modal-content">
           <h3 style="margin:0; font-size:1.1em;">选择展示内容</h3>
           <p style="margin:0; font-size:0.8em; color:var(--text-secondary-color); text-align:center;">
               选择一个文件夹在仪表盘顶部展示
           </p>
        
           <div id="showcase-folder-list" class="target-folder-list">
               <!-- JS 生成列表 -->
           </div>
        
           <button class="capsule-btn" style="width:100%; margin-top:10px;" onclick="document.getElementById('showcase-selector-modal').classList.remove('active')">取消</button>
       </div>
   </div>
   <!-- 排序：确认位置弹窗 -->
   <div class="modal-overlay" id="reorder-confirm-modal">
       <div class="glass-modal-content">
           <h3 style="margin:0; font-size:1.1em;">调整位置</h3>
           <p style="margin:0; text-align:center;">
              将 <strong id="confirm-source-name" style="color:var(--primary-color)"></strong> 放置在<br>
               <strong id="confirm-target-name" style="color:var(--text-color)"></strong> 的：
           </p>
        
           <div class="position-selector">
              <div class="position-option" id="pos-before" onclick="selectPosition('before')">前面</div>
              <div class="position-option" id="pos-after" onclick="selectPosition('after')">后面</div>
           </div>
        
           <button id="btn-confirm-move" class="capsule-btn highlight" style="width:100%; margin-top:15px;">确定移动</button>
           <button class="capsule-btn" style="width:100%;" onclick="document.getElementById('reorder-confirm-modal').classList.remove('active')">取消</button>
      </div>
</div>
     <!-- ===== GitHub 备份弹窗 (修复版) ===== -->
 <div class="modal-overlay" id="github-backup-modal">
     <div class="modal-content">
         <div class="modal-header">
             <h3>备份到 GitHub</h3>
         </div>
         
         <div class="modal-body">
             <p style="font-size: 0.85em; color: var(--text-secondary-color); margin-bottom: 20px; line-height: 1.5;">
                 数据将打包上传至您的私有仓库。
                 <a href="https://github.com/settings/tokens/new?scopes=repo&description=CharacterCardBackup" target="_blank" style="color: var(--info-color); text-decoration: none; border-bottom: 1px dashed var(--info-color);">点此生成访问令牌 (PAT)</a>，只需勾选 <code>repo</code> 权限。
             </p>
         
             <!-- 表单组 1: 用户名 -->
             <div class="github-form-group">
                 <label for="github-username" class="github-form-label">GitHub 用户名</label>
                 <input type="text" id="github-username" class="github-form-input" placeholder="例如：octocat">
             </div>

             <!-- 表单组 2: 仓库名 -->
             <div class="github-form-group">
                 <label for="github-repo" class="github-form-label">仓库名称 (私有)</label>
                 <input type="text" id="github-repo" class="github-form-input" placeholder="例如：my-card-backup">
             </div>

             <!-- 表单组 3: Token -->
             <div class="github-form-group">
                 <label for="github-token" class="github-form-label">个人访问令牌 (PAT)</label>
                 <input type="password" id="github-token" class="github-form-input" placeholder="粘贴以 ghp_ 开头的令牌">
             </div>
         
             <p id="github-status-message" style="text-align: center; margin-top: 10px; font-size: 0.85em; color: var(--warning-color); min-height: 20px;"></p>
         </div>

         <div class="modal-footer">
             <button id="btn-cancel-github-backup">取消</button>
             <button id="btn-confirm-github-backup">确认备份</button>
        </div>
    </div>
</div>
<script>
    // ==========================================
    // 1. 全局变量定义
    // ==========================================
    let db;
    let currentDetailCharId = null;
    let currentEditingNoteId = null;
    let notesSaveTimeout;
    let allCharacterCards = [];
    let currentCardIndex = 0;
    let createdImageUrls = [];
    let folders = ['默认文件夹', '我的最爱', '回收站']; 
    let currentFolder = '默认文件夹';
    let currentGachaCharId = null; 
    let dashboardImageUrls = []; // 用于仪表盘内存清理
    let currentShowcaseFolder = '我的最爱'; // 默认值
    // ==========================================
    // 2. 数据库初始化与操作
    // ==========================================
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('CardOrganizerDB', 8);
            request.onupgradeneeded = (event) => {
                const dbInstance = event.target.result;
                const tx = event.target.transaction;
                
                // characters 表
                if (!dbInstance.objectStoreNames.contains('characters')) {
                    const charStore = dbInstance.createObjectStore('characters', { keyPath: 'id', autoIncrement: true });
                    charStore.createIndex('name', 'name', { unique: false });
                    charStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                    charStore.createIndex('originalFileName', 'originalFileName', { unique: false });
                } else {
                    const charStore = tx.objectStore('characters');
                    if (!charStore.indexNames.contains('updatedAt')) charStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                    if (!charStore.indexNames.contains('originalFileName')) charStore.createIndex('originalFileName', 'originalFileName', { unique: false });
                }
                // attachments 表
                if (!dbInstance.objectStoreNames.contains('attachments')) {
                    const attachmentStore = dbInstance.createObjectStore('attachments', { keyPath: 'id' });
                    attachmentStore.createIndex('characterId', 'characterId', { unique: false });
                }
                // appdata 表
                if (!dbInstance.objectStoreNames.contains('appdata')) {
                    dbInstance.createObjectStore('appdata', { keyPath: 'key' });
                }
                // notes 表
                if (!dbInstance.objectStoreNames.contains('notes')) {
                    const noteStore = dbInstance.createObjectStore('notes', { keyPath: 'id', autoIncrement: true });
                    noteStore.createIndex('updatedAt', 'updatedAt', { unique: false });
                }
            };
            request.onsuccess = (e) => { db = e.target.result; resolve(db); };
            request.onerror = (e) => { console.error("数据库加载失败:", e.target.error); reject(e.target.error); };
        });
    }

    // 基础 CRUD 函数
    function addCharacter(d) { return new Promise((res, rej) => { const tx = db.transaction(['characters'], 'readwrite'); const req = tx.objectStore('characters').add(d); req.onsuccess = e => res(e.target.result); tx.onerror = e => rej(e.target.error); }); }
    function getAllCharacters() { return new Promise((res) => { db.transaction('characters').objectStore('characters').getAll().onsuccess = e => res(e.target.result); }); }
    function getCharacter(id) { return new Promise((res) => { db.transaction('characters').objectStore('characters').get(id).onsuccess = e => res(e.target.result); }); }
    function updateCharacter(d) { return new Promise((res, rej) => { const tx = db.transaction(['characters'], 'readwrite'); tx.objectStore('characters').put(d).onsuccess = () => res(); tx.onerror = e => rej(e.target.error); }); }
    function addAttachment(attachment) { return new Promise((res, rej) => { const tx = db.transaction(['attachments'], 'readwrite'); tx.objectStore('attachments').add(attachment).onsuccess = e => res(e.target.result); tx.onerror = e => rej(e.target.error); }); }
    function getAttachmentsByCharacterId(charId) { return new Promise((resolve, reject) => { if (!db) { resolve([]); return; } const tx = db.transaction('attachments', 'readonly'); const store = tx.objectStore('attachments'); const index = store.index('characterId'); const request = index.getAll(charId); request.onsuccess = (e) => resolve(e.target.result); request.onerror = (e) => reject(e.target.error); }); }
    function deleteAttachment(id) { return new Promise((res, rej) => { const tx = db.transaction(['attachments'], 'readwrite'); tx.objectStore('attachments').delete(id).onsuccess = () => res(); tx.onerror = e => rej(e.target.error); }); }
    
    async function deleteCharacterAndAttachments(id) { 
        const attachments = await getAttachmentsByCharacterId(id); 
        const attachmentIds = attachments.map(att => att.id); 
        return new Promise((resolve, reject) => { 
            const tx = db.transaction(['characters', 'attachments'], 'readwrite'); 
            const charStore = tx.objectStore('characters');
            const attStore = tx.objectStore('attachments');
            attachmentIds.forEach(attId => { attStore.delete(attId); });
            charStore.delete(id);
            tx.oncomplete = () => { resolve(true); };
            tx.onerror = (e) => { console.error("删除事务失败:", e.target.error); reject(e.target.error); };
        }); 
    }

    function getAppData(key) { return new Promise((res) => { try { const tx = db.transaction('appdata', 'readonly'); tx.objectStore('appdata').get(key).onsuccess = e => res(e.target.result); } catch(e){ res(null); } }); }
    function setAppData(data) { return new Promise((res, rej) => { const tx = db.transaction(['appdata'], 'readwrite'); tx.objectStore('appdata').put(data).onsuccess = () => res(); tx.onerror = e => rej(e.target.error); }); }
    function addNote(note) { return new Promise((res, rej) => { const tx = db.transaction(['notes'], 'readwrite'); tx.objectStore('notes').add(note).onsuccess = e => res(e.target.result); tx.onerror = e => rej(e.target.error); }); }
    function getAllNotes() { return new Promise((res) => { db.transaction('notes').objectStore('notes').getAll().onsuccess = e => res(e.target.result); }); }
    function getNote(id) { return new Promise((res) => { db.transaction('notes').objectStore('notes').get(id).onsuccess = e => res(e.target.result); }); }
    function updateNote(note) { return new Promise((res, rej) => { const tx = db.transaction(['notes'], 'readwrite'); tx.objectStore('notes').put(note).onsuccess = () => res(); tx.onerror = e => rej(e.target.error); }); }
    function deleteNote(id) { return new Promise((res, rej) => { const tx = db.transaction(['notes'], 'readwrite'); tx.objectStore('notes').delete(id).onsuccess = () => res(); tx.onerror = e => rej(e.target.error); }); }
    function findCharacterByFileName(fileName) { return new Promise((resolve, reject) => { const tx = db.transaction('characters', 'readonly'); const index = tx.objectStore('characters').index('originalFileName'); const request = index.get(fileName); request.onsuccess = (e) => resolve(e.target.result); request.onerror = (e) => { console.error('通过文件名查找角色失败:', e.target.error); reject(e.target.error); }; }); }
    function clearAllData() { return new Promise((resolve, reject) => { if (!db) { reject("数据库未初始化"); return; } const storesToClear = ['characters', 'attachments', 'notes', 'appdata']; const tx = db.transaction(storesToClear, 'readwrite'); storesToClear.forEach(storeName => { if (db.objectStoreNames.contains(storeName)) { tx.objectStore(storeName).clear(); } }); tx.oncomplete = () => resolve(); tx.onerror = (e) => reject(e.target.error); }); }

    // ==========================================
    // 3. 工具与解析函数
    // ==========================================
    const fileIcons = {
        default: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 2v6h6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
        image: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><rect x="3" y="3" width="18" height="18" rx="2" ry="2" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><circle cx="8.5" cy="8.5" r="1.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="m21 15-5-5L5 21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
        pdf: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 2v6h6M10.25 18H14M12 12v6M9 15.5c0-1 .8-2 2-2s2 .8 2 2.1-.8 2-2 2-2-.8-2-2Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
        word: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M14 2v6h6M8 12h8M8 16h8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
        archive: `<svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21 8v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M23 6H1v2h22V6zM10 12h4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
    };
    function getFileIcon(fileName) {
        const extension = fileName.slice(fileName.lastIndexOf('.')).toLowerCase();
        if (['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'].includes(extension)) return fileIcons.image;
        if (extension === '.pdf') return fileIcons.pdf;
        if (['.doc', '.docx'].includes(extension)) return fileIcons.word;
        if (['.zip', '.rar', '.7z'].includes(extension)) return fileIcons.archive;
        return fileIcons.default;
    }
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function base64Decode(str) { try { return decodeURIComponent(atob(str).split('').map(function(c) { return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2); }).join('')); } catch (e) { console.error("Base64解码失败:", e); return null; } }
    async function extractCharacterDataFromPng(file) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { const arr = new Uint8Array(e.target.result); let offset = 8; while (offset < arr.length) { const length = (arr[offset] << 24) | (arr[offset + 1] << 16) | (arr[offset + 2] << 8) | arr[offset + 3]; const type = String.fromCharCode(arr[offset + 4], arr[offset + 5], arr[offset + 6], arr[offset + 7]); if (type === 'tEXt') { const chunkData = arr.subarray(offset + 8, offset + 8 + length); let keyword = '', content = '', separatorFound = false; for(let i = 0; i < chunkData.length; i++) { const charCode = chunkData[i]; if (charCode === 0) { separatorFound = true; continue; } if (!separatorFound) keyword += String.fromCharCode(charCode); else content += String.fromCharCode(charCode); } if (keyword === 'chara') { const decodedData = base64Decode(content); if (decodedData) { resolve(JSON.parse(decodedData)); return; } } } if (type === 'IEND') break; offset += 12 + length; } reject('在PNG中未找到角色数据'); }; reader.onerror = reject; reader.readAsArrayBuffer(file); }); }
    function compressImage(file, options = {}) {
         return new Promise((resolve, reject) => {
             const { maxWidth = 800, maxHeight = 800, quality = 0.7 } = options;
             const img = new Image();
             const reader = new FileReader();
             reader.onload = (e) => { img.src = e.target.result; };
             reader.onerror = reject;
             img.onload = () => {
                let width = img.width;
                let height = img.height;
                if (width > height) {
                   if (width > maxWidth) { height = Math.round(height * (maxWidth / width)); width = maxWidth; }
                } else {
                   if (height > maxHeight) { width = Math.round(width * (maxHeight / height)); height = maxHeight; }
                }
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                canvas.toBlob((blob) => {
                       if (blob) {
                          const compressedFile = new File([blob], file.name, { type: file.type, lastModified: Date.now() });
                          resolve(compressedFile);
                       } else { reject(new Error('Canvas to Blob conversion failed.')); }
                   }, file.type, quality);
            };
            img.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    // ==========================================
    // 4. 核心业务逻辑 (全局作用域)
    // ==========================================
    
    // --- 仪表盘更新逻辑 (支持自定义文件夹) ---
    async function updateDashboard() {
         if (!db) return;

         const favContainer = document.getElementById('fav-showcase-container');
         const statsContainer = document.getElementById('folder-stats-grid');
         const titleEl = document.getElementById('dashboard-showcase-title');

         // 1. 更新标题文字
         if (titleEl) {
             // 根据文件夹名字给个不同的 emoji (可选)
             let icon = '📂';
             if (currentShowcaseFolder === '我的最爱') icon = '💖';
             else if (currentShowcaseFolder === '回收站') icon = '🗑️';
         
             titleEl.innerHTML = `${icon} ${currentShowcaseFolder} <span style="font-size:0.7em; opacity:0.5;">▼</span>`;
         }

         if (favContainer) favContainer.innerHTML = '<div class="loading-placeholder"></div>';
         if (statsContainer) statsContainer.innerHTML = '<div class="loading-placeholder"></div>';
 
        if (dashboardImageUrls.length > 0) {
           dashboardImageUrls.forEach(url => URL.revokeObjectURL(url));
           dashboardImageUrls = [];
        }

        try {
            const allChars = await getAllCharacters();

            // A. 渲染文件夹统计
            const folderCounts = {};
            folders.forEach(f => folderCounts[f] = 0);
            allChars.forEach(char => {
            const fName = char.folder || '默认文件夹';
                if (folderCounts[fName] === undefined) folderCounts[fName] = 0;
                folderCounts[fName]++;
            });
  
            if (statsContainer) {
               statsContainer.innerHTML = '';
               // 遍历所有文件夹 (确保顺序和资料库一致)
               folders.forEach(folderName => {
                  const count = folderCounts[folderName] || 0; // 如果是0也显示
        
                  const div = document.createElement('div');
                  div.className = 'folder-stat-chip';
                  div.dataset.folder = folderName; // 用于 CSS 特殊样式
        
                  // 新的结构：名字在前，数量在后 (或者反过来，看你喜好，这里保持风格一致)
                 // 资料库导航是纯文字，这里我们做成 "名字 数量" 的胶囊
                 div.innerHTML = `<span class="folder-stat-name">${folderName}</span> <span class="folder-stat-count">${count}</span>`;
        
                 statsContainer.appendChild(div);
               });
            }

            // B. 渲染画廊 (使用 currentShowcaseFolder 变量)
            // 筛选条件改为：文件夹等于当前选择的文件夹
            const targetChars = allChars.filter(c => {
                const cFolder = c.folder || '默认文件夹';
                return cFolder === currentShowcaseFolder;
            });
        
            if (favContainer) {
                favContainer.innerHTML = '';
                if (targetChars.length === 0) {
                    favContainer.innerHTML = `<div class="empty-state-text">"${currentShowcaseFolder}" 是空的<br>快去添加一些角色卡吧</div>`;
                } else {
                   // 取前10个
                   const topChars = targetChars.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt)).slice(0, 10);
                   const fragment = document.createDocumentFragment();
              
                   topChars.forEach(char => {
                       const div = document.createElement('div');
                       div.className = 'fav-card-item';
                       let imgHtml = '';
                       const fileForDisplay = char.thumbnailFile || char.originalFile;
                       if (fileForDisplay && fileForDisplay.type.startsWith('image/')) {
                           const url = URL.createObjectURL(fileForDisplay);
                           dashboardImageUrls.push(url);
                           imgHtml = `<img src="${url}" loading="lazy">`;
                       } else {
                          imgHtml = `<div style="display:flex;justify-content:center;align-items:center;height:100%;font-size:2em;color:#555;">{}</div>`;
                       }
                       div.innerHTML = `${imgHtml}<div class="fav-card-name">${char.name}</div>`;
                       div.onclick = () => openDetailView(char.id);
                       fragment.appendChild(div);
                   });
                   favContainer.appendChild(fragment);
                }
            }
        } catch (error) {
             console.error("更新仪表盘失败:", error);
             if (favContainer) favContainer.innerHTML = '<div class="empty-state-text" style="color:var(--danger-color)">加载失败，请刷新重试</div>';
        }
    }

    // --- 抽卡逻辑 ---
    function resetGacha() {
         const gachaCard = document.getElementById('gacha-card');
         const summonBtn = document.getElementById('btn-summon');
         const gachaActions = document.getElementById('gacha-actions');
         
         gachaCard.classList.remove('flipped');
         gachaActions.classList.remove('show');
         summonBtn.style.display = 'flex';
         summonBtn.disabled = false;
         summonBtn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/></svg><span>开始召唤</span>`;
    }

    async function performSummon() {
        const allChars = await getAllCharacters();
        const summonBtn = document.getElementById('btn-summon');
        const gachaCard = document.getElementById('gacha-card');
        const flashOverlay = document.getElementById('gacha-flash');
        const gachaActions = document.getElementById('gacha-actions');

        if (allChars.length === 0) {
           alert("资料库是空的，先去上传一些角色卡吧！");
           return;
        }

       summonBtn.disabled = true;
       summonBtn.textContent = "召唤中...";
    
       const randomIndex = Math.floor(Math.random() * allChars.length);
       const winner = allChars[randomIndex];
       currentGachaCharId = winner.id;

       const fileForDisplay = winner.thumbnailFile || winner.originalFile;
       let imageUrl = '';
       if (fileForDisplay && fileForDisplay.type.startsWith('image/')) {
           imageUrl = URL.createObjectURL(fileForDisplay);
       }
       document.getElementById('gacha-result-img').src = imageUrl;
       document.getElementById('gacha-result-name').textContent = winner.name;
       document.getElementById('gacha-result-folder').textContent = winner.folder || '默认文件夹';

       gachaCard.classList.add('shaking');
    
       setTimeout(() => {
           gachaCard.classList.remove('shaking');
           flashOverlay.classList.add('active');
           setTimeout(() => {
               flashOverlay.classList.remove('active');
               gachaCard.classList.add('flipped');
               summonBtn.style.display = 'none';
               setTimeout(() => {
                   gachaActions.classList.add('show');
              }, 400);
          }, 150);
      }, 800);
    }

    // --- 渲染卡片堆叠 ---
    async function renderAllCharacterCards(charactersToRender) {
        createdImageUrls.forEach(url => URL.revokeObjectURL(url));
        createdImageUrls = [];
        const cardContainer = document.getElementById('card-stack-container');
        if (!cardContainer) return;
        cardContainer.innerHTML = '';

        let allChars = charactersToRender;
        if (!allChars) {
           allChars = await getAllCharacters();
        }

        const filteredChars = allChars.filter(char => {
             const charFolder = (char.folder && char.folder.trim() !== '') ? char.folder : '默认文件夹';
             const targetFolder = (currentFolder && currentFolder.trim() !== '') ? currentFolder : '默认文件夹';
             return charFolder === targetFolder;
        });

        filteredChars.sort((a, b) => new Date(b.updatedAt || 0) - new Date(a.updatedAt || 0));
    
        if (filteredChars.length === 0) {
            cardContainer.innerHTML = `<div style="color:var(--text-secondary-color); text-align:center; padding-top:100px;">
                <h3>"${currentFolder}" 是空的</h3>
                <p>去其他文件夹看看，或者添加新卡片</p>
           </div>`;
           allCharacterCards = [];
           currentCardIndex = 0;
           return;
        }

        filteredChars.forEach(charData => {
           const thumb = document.createElement('div');
           thumb.className = 'card-thumb';
           thumb.dataset.id = charData.id;
           let imageHtml;
           const fileForDisplay = charData.thumbnailFile || charData.originalFile;
           if (fileForDisplay && fileForDisplay.type.startsWith('image/')) {
               const imageUrl = URL.createObjectURL(fileForDisplay);
               createdImageUrls.push(imageUrl);
               imageHtml = `<img src="${imageUrl}" alt="${charData.name}">`;
           } else {
              imageHtml = `<div class="json-icon">{}</div>`;
           }
           thumb.innerHTML = `<div class="card-image-wrapper">${imageHtml}</div><div class="name-bar">${charData.name}</div>`;
            cardContainer.appendChild(thumb);
        });
        initCardStack();
    }
    
    function initCardStack() { allCharacterCards = Array.from(document.querySelectorAll('#card-stack-container .card-thumb')); currentCardIndex = 0; updateCardStackUI(); }
    function updateCardStackUI() { allCharacterCards.forEach((card, index) => { card.classList.remove('current', 'next', 'after-next', 'dismiss-left', 'dismiss-right'); if (index === currentCardIndex) { card.classList.add('current'); } else if (index === currentCardIndex + 1) { card.classList.add('next'); } else if (index === currentCardIndex + 2) { card.classList.add('after-next'); } }); }
    function dismissCard(direction) { if (currentCardIndex >= allCharacterCards.length) { if (confirm("已经是最后一张了，要从头开始吗？")) { currentCardIndex = 0; updateCardStackUI(); } return; } const cardToDismiss = allCharacterCards[currentCardIndex]; cardToDismiss.classList.add(direction === 'left' ? 'dismiss-left' : 'dismiss-right'); currentCardIndex++; setTimeout(() => { updateCardStackUI(); }, 100); }

    // --- 详情页逻辑 ---
    async function openDetailView(charId) {
        currentDetailCharId = charId;
        const charData = await getCharacter(charId);
        if (!charData) return;
        const detailView = document.getElementById('card-detail-view');
        const fileForDisplay = charData.thumbnailFile || charData.originalFile;
        let imageUrl = '';
        if (fileForDisplay && fileForDisplay.type.startsWith('image/')) {
           imageUrl = URL.createObjectURL(fileForDisplay);
        }
        document.getElementById('detail-avatar').src = imageUrl;
        document.getElementById('detail-image').src = imageUrl;
        document.getElementById('detail-name').textContent = charData.name;
        document.getElementById('detail-description').textContent = charData.description;
        document.getElementById('detail-timestamp').textContent = `更新于 ${new Date(charData.updatedAt).toLocaleString()}`;
        const attachments = await getAttachmentsByCharacterId(charId);
        const badge = document.getElementById('attachment-count-badge');
        badge.textContent = attachments.length;
        badge.style.display = attachments.length > 0 ? 'inline-block' : 'none';
        populateDetailFolderSelect(charData);
        detailView.classList.add('active');
   }
   
   function closeDetailView() {
        const detailView = document.getElementById('card-detail-view');
        detailView.classList.remove('active');
        setTimeout(() => {
            const avatar = document.getElementById('detail-avatar');
            const image = document.getElementById('detail-image');
            if (avatar.src && avatar.src.startsWith('blob:')) URL.revokeObjectURL(avatar.src);
            if (image.src && image.src.startsWith('blob:')) URL.revokeObjectURL(image.src);
            avatar.src = ''; image.src = '';
        }, 400);
    }
    
    function populateDetailFolderSelect(charData) {
        const select = document.getElementById('detail-folder-select');
        select.innerHTML = '';
        folders.forEach(folder => {
           const option = document.createElement('option'); option.value = folder; option.textContent = folder;
           if (charData.folder === folder || (!charData.folder && folder === '默认文件夹')) { option.selected = true; }
           select.appendChild(option);
       });
       select.onchange = async (e) => { const newFolder = e.target.value; charData.folder = newFolder; await updateCharacter(charData); alert(`已移动到 "${newFolder}"`); if (currentFolder !== newFolder) await renderAllCharacterCards(); };
    }

    async function renderAttachmentsPage(charId) {
        const charData = await getCharacter(charId);
        if (!charData) return;
        document.getElementById('attachments-page-title').textContent = `${charData.name}的附件`;
        const listEl = document.getElementById('attachments-detail-list');
        const attachments = await getAttachmentsByCharacterId(charId);
        listEl.innerHTML = '';
        if (attachments.length === 0) {
           listEl.innerHTML = `<div class="empty-attachments-placeholder"><svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><h3>没有附件</h3><p>你可以返回详情页为该角色添加附件</p></div>`;
      } else {
         attachments.forEach(att => {
              const li = document.createElement('li');
              li.dataset.id = att.id;
              const fileIconHtml = getFileIcon(att.fileName);
              const fileSize = formatFileSize(att.file.size);
              const fileDate = new Date(att.file.lastModified).toLocaleDateString();
              li.innerHTML = `<div class="attachment-icon">${fileIconHtml}</div><div class="attachment-info"><div class="attachment-name">${att.fileName}</div><div class="attachment-meta">${fileSize}・添加于 ${fileDate}</div></div><button class="delete-attachment-btn" title="删除此附件">&times;</button>`;
             li.querySelector('.attachment-info').onclick = () => {
                  const url = URL.createObjectURL(att.file);
                  const a = document.createElement('a'); a.href = url; a.download = att.fileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
             };
             li.querySelector('.delete-attachment-btn').onclick = async (e) => {
                e.stopPropagation();
                if (confirm(`确定要删除附件 "${att.fileName}" 吗？`)) { await deleteAttachment(att.id); await renderAttachmentsPage(charId); await updateDashboard(); }
             };
             listEl.appendChild(li);
        });
      }
   }

   // --- 文件夹管理 ---
   async function loadFolders() {
        try {
            const storedFolders = await getAppData('folderList');
            if (storedFolders && Array.isArray(storedFolders.value) && storedFolders.value.length > 0) {
               folders = storedFolders.value;
            } else {
               folders = ['默认文件夹', '我的最爱', '回收站'];
               await saveFolders();
            }
            if (!folders.includes(currentFolder)) currentFolder = '默认文件夹';
            renderFolderNav();
       } catch (e) {
           console.error("加载文件夹失败，使用默认配置", e);
           folders = ['默认文件夹', '我的最爱', '回收站'];
           renderFolderNav();
       }
    }
    async function saveFolders() { await setAppData({ key: 'folderList', value: folders }); renderFolderNav(); }
    function renderFolderNav() {
       const container = document.getElementById('folder-nav');
       container.innerHTML = '';
       folders.forEach(folder => {
           const chip = document.createElement('div');
           chip.className = `folder-chip ${folder === currentFolder ? 'active' : ''}`;
           chip.textContent = folder;
           chip.onclick = () => switchFolder(folder);
           if (folder !== '默认文件夹' && folder !== '回收站') {
              chip.oncontextmenu = (e) => { e.preventDefault(); openFolderOptions(folder); };
           }
           container.appendChild(chip);
       });
       const addBtn = document.createElement('div');
       addBtn.className = 'folder-chip add-btn';
       addBtn.textContent = '+ 新建';
       addBtn.onclick = createNewFolder;
       container.appendChild(addBtn);
    }
    async function switchFolder(folderName) { currentFolder = folderName; renderFolderNav(); await renderAllCharacterCards(); }
    async function createNewFolder() { const name = prompt("请输入新文件夹名称："); if (name && !folders.includes(name)) { folders.push(name); await saveFolders(); } else if (folders.includes(name)) { alert("文件夹已存在！"); } }
    async function deleteFolder(folderName) {
        const allChars = await getAllCharacters();
        for (const char of allChars) { if (char.folder === folderName) { char.folder = '默认文件夹'; await updateCharacter(char); } }
        folders = folders.filter(f => f !== folderName);
        if (currentFolder === folderName) currentFolder = '默认文件夹';
        await saveFolders(); await renderAllCharacterCards();
    }
    async function renameFolder(oldName) {
        const modal = document.getElementById('folder-options-modal');
        modal.classList.remove('active'); 
        const newName = prompt("请输入新的文件夹名称：", oldName);
        if (!newName || newName.trim() === "" || newName === oldName) return;
        if (folders.includes(newName)) { alert("该文件夹名称已存在！"); return; }
        const index = folders.indexOf(oldName);
        if (index !== -1) folders[index] = newName;
        if (currentFolder === oldName) currentFolder = newName;
        try {
            const allChars = await getAllCharacters();
            for (const char of allChars) { if (char.folder === oldName) { char.folder = newName; await updateCharacter(char); } }
        } catch (e) { console.error("重命名更新角色失败:", e); }
        await saveFolders(); await renderAllCharacterCards(); alert(`文件夹已重命名为 "${newName}"`);
    }
    // 全局变量用于存储排序状态
    let folderToMove = null;
    let folderMoveTarget = null;
    let folderMovePosition = 'after'; // 'before' or 'after'

    // 1. 修改：打开文件夹操作菜单 (增加排序按钮)
    function openFolderOptions(folderName) {
        const modal = document.getElementById('folder-options-modal');
        document.getElementById('folder-options-name').textContent = folderName;
 
        // 绑定重命名
        document.getElementById('btn-opt-rename').onclick = () => renameFolder(folderName);

        // 绑定删除
        document.getElementById('btn-opt-delete').onclick = () => {
            modal.classList.remove('active');
            if(confirm(`确定要删除文件夹 "${folderName}" 吗？\n\n注意：该文件夹下的所有角色卡将自动移动到“默认文件夹”，不会被删除。`)) {
               deleteFolder(folderName);
            }
        };

        // ===== 新增：插入排序按钮 =====
        // 检查是否已经存在排序按钮，避免重复添加
        let sortBtn = document.getElementById('btn-opt-sort');
        if (!sortBtn) {
            sortBtn = document.createElement('button');
            sortBtn.id = 'btn-opt-sort';
            sortBtn.style.cssText = "padding:12px; background:var(--panel-secondary-color); border:1px solid var(--border-color); color:var(--text-color); border-radius:12px; cursor:pointer; font-size:1em;";
             sortBtn.innerHTML = "移动/排序";
             // 插入到删除按钮之前
             const deleteBtn = document.getElementById('btn-opt-delete');
             deleteBtn.parentNode.insertBefore(sortBtn, deleteBtn);
        }
    
        sortBtn.onclick = () => {
            modal.classList.remove('active');
            openReorderModal(folderName);
        };

        modal.classList.add('active');
    }

    // 2. 新增：打开排序选择弹窗
    function openReorderModal(sourceName) {
         folderToMove = sourceName;
         document.getElementById('move-source-name').textContent = sourceName;
    
         const listContainer = document.getElementById('reorder-target-list');
         listContainer.innerHTML = '';
    
         // 遍历所有文件夹生成胶囊按钮
         folders.forEach(f => {
             // 不能移动到自己身上
             if (f === sourceName) return;
        
             const btn = document.createElement('div');
             btn.className = 'capsule-btn';
             btn.textContent = f;
             btn.onclick = () => openConfirmPositionModal(f);
             listContainer.appendChild(btn);
         });
    
         document.getElementById('folder-reorder-modal').classList.add('active');
    }

    // 3. 新增：打开位置确认弹窗
    function openConfirmPositionModal(targetName) {
         folderMoveTarget = targetName;
         document.getElementById('folder-reorder-modal').classList.remove('active');
    
         document.getElementById('confirm-source-name').textContent = folderToMove;
         document.getElementById('confirm-target-name').textContent = targetName;
    
         // 默认选中 "后面"
         selectPosition('after');
    
         document.getElementById('reorder-confirm-modal').classList.add('active');
    }

    // 4. 新增：选择位置 UI 切换
    function selectPosition(pos) {
       folderMovePosition = pos;
       document.getElementById('pos-before').classList.toggle('selected', pos === 'before');
       document.getElementById('pos-after').classList.toggle('selected', pos === 'after');
    }

    // 5. 新增：执行移动逻辑 (核心算法)
    document.getElementById('btn-confirm-move').addEventListener('click', async () => {
        if (!folderToMove || !folderMoveTarget) return;
    
        // 1. 从数组中移除源文件夹
        const oldIndex = folders.indexOf(folderToMove);
        if (oldIndex > -1) {
            folders.splice(oldIndex, 1);
        }
    
        // 2. 找到目标文件夹的新索引
       let targetIndex = folders.indexOf(folderMoveTarget);
    
       // 3. 根据 before/after 决定插入位置
       if (folderMovePosition === 'after') {
          targetIndex++; 
       }
    
       // 4. 插入
       folders.splice(targetIndex, 0, folderToMove);
    
       // 5. 保存并刷新
       await saveFolders();
    
       document.getElementById('reorder-confirm-modal').classList.remove('active');
    
      // 提示
      const posText = folderMovePosition === 'before' ? '前面' : '后面';
      // alert(`已将 "${folderToMove}" 移动到 "${folderMoveTarget}" 的${posText}`);
   });

   // ===== 补充：让默认文件夹也能触发长按菜单 =====
   // 修改 renderFolderNav 函数中的逻辑
   function renderFolderNav() {
      const container = document.getElementById('folder-nav');
      container.innerHTML = '';
      folders.forEach(folder => {
          const chip = document.createElement('div');
          chip.className = `folder-chip ${folder === currentFolder ? 'active' : ''}`;
          chip.textContent = folder;
          chip.onclick = () => switchFolder(folder);
       
         // 修改这里：现在允许所有文件夹（包括默认）触发右键/长按菜单
         chip.oncontextmenu = (e) => { 
             e.preventDefault(); 
             openFolderOptions(folder); 
         };
       
         container.appendChild(chip);
      });
      const addBtn = document.createElement('div');
      addBtn.className = 'folder-chip add-btn';
      addBtn.textContent = '+ 新建';
      addBtn.onclick = createNewFolder;
      container.appendChild(addBtn);
   }
    // --- 文件导入导出 ---
    async function handleFileDrop(files) {
        for (const file of files) {
            try {
                if (!file.type.startsWith('image/') && !file.name.endsWith('.json')) { console.warn(`跳过不支持的文件类型: ${file.name}`); continue; }
                const existingChar = await findCharacterByFileName(file.name);
                if (existingChar) { await handleConflict(file, existingChar); } else { await saveNewCharacter(file); }
            } catch (error) { console.error(`处理文件 ${file.name} 失败:`, error); alert(`处理文件 ${file.name} 时发生错误。`); }
        }
        await renderAllCharacterCards();
        await updateDashboard();
    }
    async function saveNewCharacter(file, asNewName = false) {
        let charJson;
        let thumbnailBlob = null;
       if (file.type.startsWith('image/')) {
           try {
               const thumbnailFile = await compressImage(file, { maxWidth: 1200, maxHeight: 1200, quality: 0.95 });
               thumbnailBlob = new Blob([await thumbnailFile.arrayBuffer()], { type: thumbnailFile.type });
           } catch (error) { console.error('生成预览图失败:', error); thumbnailBlob = null; }
       }
       const originalFileBlob = new Blob([await file.arrayBuffer()], { type: file.type });
       if (file.type === 'image/png') { try { charJson = await extractCharacterDataFromPng(file); } catch (e) { charJson = { name: file.name.replace(/\.[^/.]+$/, ""), description: "无描述" }; } } 
       else if (file.name.endsWith('.json')) { charJson = JSON.parse(await file.text()); } 
       else if (file.type.startsWith('image/')) { charJson = { name: file.name.replace(/\.[^/.]+$/, ""), description: "无描述" }; }
       else { return; }
       let name = charJson.name || (charJson.data ? charJson.data.name : '未知');
       if (asNewName) { name = `${name} (副本)`; }
       const description = charJson.description || (charJson.data ? charJson.data.description : '无描述');
       const characterToSave = { name, description, notes: '', folder: currentFolder, originalFile: originalFileBlob, thumbnailFile: thumbnailBlob, originalFileName: file.name, updatedAt: new Date().toISOString() };
       return await addCharacter(characterToSave);
    }
    async function overwriteCharacter(file, existingChar) {
        let charJson;
        let thumbnailBlob = null;
        if (file.type.startsWith('image/')) {
           try {
               const thumbnailFile = await compressImage(file, { maxWidth: 1200, maxHeight: 1200, quality: 0.95 });
               thumbnailBlob = new Blob([await thumbnailFile.arrayBuffer()], { type: thumbnailFile.type });
           } catch (error) { thumbnailBlob = existingChar.thumbnailFile || null; }
        }
        const originalFileBlob = new Blob([await file.arrayBuffer()], { type: file.type });
        if (file.type === 'image/png') { try { charJson = await extractCharacterDataFromPng(file); } catch (e) { charJson = { name: file.name.replace(/\.[^/.]+$/, ""), description: "无描述" }; } } 
        else if (file.name.endsWith('.json')) { charJson = JSON.parse(await file.text()); } 
        else if (file.type.startsWith('image/')) { charJson = { name: file.name.replace(/\.[^/.]+$/, ""), description: "无描述" }; }
        else { return; }
        const name = charJson.name || (charJson.data ? charJson.data.name : '未知');
        const description = charJson.description || (charJson.data ? charJson.data.description : '无描述');
        const characterToUpdate = { ...existingChar, name, description, originalFile: originalFileBlob, thumbnailFile: thumbnailBlob, originalFileName: file.name, updatedAt: new Date().toISOString() };
        await updateCharacter(characterToUpdate);
    }
    function handleConflict(file, existingChar) {
        return new Promise((resolve) => {
            const conflictModal = document.getElementById('conflict-modal');
            document.getElementById('conflict-char-name').textContent = existingChar.name;
            const btnOverwrite = document.getElementById('btn-overwrite');
            const btnSaveAsNew = document.getElementById('btn-save-as-new');
            const btnCancel = document.getElementById('btn-cancel-conflict');
            const closeAndResolve = async (action) => {
                conflictModal.classList.remove('active');
                btnOverwrite.onclick = null; btnSaveAsNew.onclick = null; btnCancel.onclick = null;
                if (action) await action();
                resolve();
            }
            btnOverwrite.onclick = () => closeAndResolve(() => overwriteCharacter(file, existingChar));
            btnSaveAsNew.onclick = () => closeAndResolve(() => saveNewCharacter(file, true));
            btnCancel.onclick = () => closeAndResolve(null);
            conflictModal.classList.add('active');
        });
    }
    // 新的函数：只负责生成 ZIP 文件的 Blob 对象
    async function generateBackupZipBlob() {
        if (typeof JSZip === 'undefined') {
            alert('导出库加载失败，请检查网络连接或刷新页面后重试。');
            return null;
        }
        const allChars = await getAllCharacters();
        if (allChars.length === 0) {
            alert('资料库中没有角色卡可供导出。');
            return null;
        }

        const allNotes = await getAllNotes();
        const zip = new JSZip();
        const rootFolderName = '角色卡备份';
        const rootFolder = zip.folder(rootFolderName);
        const folderNames = new Set();

        for (const charData of allChars) {
            if (!charData.originalFile) continue;
            let charFolderName = charData.name || '未命名角色';
            let counter = 1;
            let finalFolderName = charFolderName;
            while (folderNames.has(finalFolderName.toLowerCase())) {
                finalFolderName = `${charFolderName} (${counter})`;
                counter++;
            }
            folderNames.add(finalFolderName.toLowerCase());
            const charFolder = rootFolder.folder(finalFolderName);
            const charName = charData.name || '未命名角色';
            const originalFileName = charData.originalFileName || '';
            const extension = originalFileName.slice(originalFileName.lastIndexOf('.'));
            const mainCardFileName = `${charName}${extension}`;
            charFolder.file(mainCardFileName, charData.originalFile);

            const linkedNotes = allNotes.filter(note => note.linkedCharId == charData.id);
            if (linkedNotes.length > 0) {
                const usedNoteNames = new Set();
                for (const note of linkedNotes) {
                    let baseName = (note.title || '无标题笔记').trim().replace(/[\\/:\*\?"<>\|]/g, '_');
                    let noteFileName = `${baseName}.txt`;
                    let noteCounter = 1;
                    while (usedNoteNames.has(noteFileName)) {
                        noteFileName = `${baseName} (${noteCounter}).txt`;
                        noteCounter++;
                    }
                    usedNoteNames.add(noteFileName);
                    const noteContent = note.content || '';
                    charFolder.file(noteFileName, noteContent);
                }
            }

            const attachments = await getAttachmentsByCharacterId(charData.id);
            if (attachments.length > 0) {
                const attachmentsFolder = charFolder.folder('附件');
                for (const attachment of attachments) {
                   attachmentsFolder.file(attachment.fileName, attachment.file);
                }
            }
        }
        return await zip.generateAsync({ type: 'blob' });
    }
 
    // 旧的函数现在调用新函数来完成本地下载
    async function exportAllCharactersAsZip() {
        const zipBlob = await generateBackupZipBlob();
        if (!zipBlob) return;

        try {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[-T:]/g, '');
            const zipFileName = `角色卡资料库备份_${timestamp}.zip`;
            const url = URL.createObjectURL(zipBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = zipFileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('已开始导出所有角色卡及其附件和关联笔记！');
        } catch (error) {
            console.error('生成ZIP文件失败:', error);
            alert('导出失败，请查看控制台获取详细信息。');
        }
    }
    async function importFromBackup(file) {
        if (typeof JSZip === 'undefined') { alert('导入库加载失败，请刷新页面重试。'); return; }
        try {
            const zip = await JSZip.loadAsync(file);
            let charCount = 0;
            let attachmentCount = 0;
            const folderToCharIdMap = new Map();
            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir || relativePath.includes('__MACOSX') || relativePath.includes('.DS_Store')) continue;
                if (!relativePath.includes('/附件/') && (relativePath.match(/\.(png|json)$/i))) {
                    const blob = await zipEntry.async('blob');
                    const fileObj = new File([blob], zipEntry.name.split('/').pop(), { type: blob.type });
                    const newCharId = await saveNewCharacter(fileObj); 
                    const parentFolder = relativePath.substring(0, relativePath.lastIndexOf('/') + 1);
                    folderToCharIdMap.set(parentFolder, newCharId);
                    charCount++;
                }
            }
            for (const [relativePath, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir || relativePath.includes('__MACOSX') || relativePath.includes('.DS_Store')) continue;
                if (relativePath.includes('/附件/')) {
                    const parts = relativePath.split('/');
                    const attachmentIndex = parts.indexOf('附件');
                    if (attachmentIndex > 0) {
                        const charFolderPath = parts.slice(0, attachmentIndex).join('/') + '/';
                        const charId = folderToCharIdMap.get(charFolderPath);
                        if (charId) {
                            const blob = await zipEntry.async('blob');
                            const fileName = parts[parts.length-1];
                            const fileObj = new File([blob], fileName);
                            await addAttachment({ id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, characterId: charId, fileName: fileName, file: fileObj });
                            attachmentCount++;
                        }
                    }
                }
            }
            alert(`导入完成！\n成功恢复了 ${charCount} 张角色卡和 ${attachmentCount} 个附件。\n页面即将刷新。`);
            location.reload();
        } catch (error) { console.error("导入ZIP失败:", error); alert("导入失败，文件可能已损坏或格式不正确。"); }
    }
    async function exportCharacterCard(charId) {
        const charData = await getCharacter(charId);
        if (!charData || !charData.originalFile) { alert('无法导出：未找到角色卡数据或原始文件。'); return; }
        const charName = charData.name || '未命名角色';
        const originalFileName = charData.originalFileName || '';
        const extension = originalFileName.slice(originalFileName.lastIndexOf('.'));
        const newFileName = `${charName}${extension}`;
        const url = URL.createObjectURL(charData.originalFile);
        const a = document.createElement('a'); a.href = url; a.download = newFileName; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        alert(`角色卡 "${charName}" 已开始导出！`);
    }
// 新增：GitHub 备份核心函数
    async function backupToGitHub() {
        const username = document.getElementById('github-username').value.trim();
        const repo = document.getElementById('github-repo').value.trim();
        const token = document.getElementById('github-token').value.trim();
        const statusMsg = document.getElementById('github-status-message');
        const confirmBtn = document.getElementById('btn-confirm-github-backup');

        if (!username || !repo || !token) {
            statusMsg.textContent = '请填写所有字段。';
            return;
        }

        statusMsg.textContent = '正在生成备份文件...';
        confirmBtn.disabled = true;
  
        const zipBlob = await generateBackupZipBlob();
        if (!zipBlob) {
            statusMsg.textContent = '生成备份文件失败。';
            confirmBtn.disabled = false;
            return;
        }

        statusMsg.textContent = '正在将文件转换为 Base64...';
  
        const reader = new FileReader();
        reader.readAsDataURL(zipBlob);
        reader.onloadend = async () => {
            const base64Content = reader.result.split(',')[1];
            const filePath = 'CharacterBackup.zip';
            const apiUrl = `https://api.github.com/repos/${username}/${repo}/contents/${filePath}`;

            statusMsg.textContent = '正在连接到 GitHub...';

            let sha = null;
            try {
                // 尝试获取现有文件信息，以获得 SHA 值用于更新
                const response = await fetch(apiUrl, {
                    headers: { 'Authorization': `token ${token}` }
                });
                if (response.ok) {
                    const data = await response.json();
                    sha = data.sha;
                    statusMsg.textContent = '检测到旧备份，准备更新...';
                } else {
                    statusMsg.textContent = '未检测到旧备份，将创建新文件...'; 
                }
            } catch (e) {
                // 网络错误等，但我们继续尝试上传
                statusMsg.textContent = '无法检查旧备份，尝试直接创建...';
            }

            const commitMessage = `自动备份: ${new Date().toLocaleString()}`;
            const uploadData = {
                message: commitMessage,
                content: base64Content,
                sha: sha // 如果是新文件，sha 为 null 也可以
            };

            try {
                statusMsg.textContent = '正在上传备份文件...';
                const uploadResponse = await fetch(apiUrl, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    },
                    body: JSON.stringify(uploadData)
                });

                if (uploadResponse.ok) {
                    statusMsg.textContent = '备份成功！';
                    setTimeout(() => {
                        document.getElementById('github-backup-modal').classList.remove('active');
                        confirmBtn.disabled = false;
                    }, 2000);
                } else {
                    const errorData = await uploadResponse.json();
                    statusMsg.textContent = `上传失败: ${errorData.message || uploadResponse.statusText}`;
                    confirmBtn.disabled = false;
                }
            } catch (error) {
                statusMsg.textContent = '上传时发生网络错误。';
                confirmBtn.disabled = false;
            }
        };
        reader.onerror = () => {
            statusMsg.textContent = '文件转换失败。';
            confirmBtn.disabled = false;
        };
    }
    // --- 页面导航与笔记 ---
    function showPage(pageId) { 
        document.querySelectorAll('.page').forEach(p => p.classList.remove('active')); 
        document.getElementById(pageId).classList.add('active'); 
        if (pageId === 'page-dashboard') {
            updateDashboard();
        }
    }
    // 替换原有的 renderNoteList 函数
async function renderNoteList() { 
    const noteList = document.getElementById('note-list'); 
    if (!noteList) return; 
    
    // 1. 获取搜索词
    const searchInput = document.getElementById('note-search-input');
    const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

    // 2. 获取所有笔记
    let notes = await getAllNotes(); 
    notes.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt)); 
    
    // 3. 准备角色映射 (用于搜索关联角色名)
    const allChars = await getAllCharacters();
    const charMap = {};
    allChars.forEach(c => charMap[c.id] = c.name.toLowerCase());

    // 4. 执行过滤
    if (searchTerm) {
        notes = notes.filter(note => {
            const titleMatch = (note.title || '').toLowerCase().includes(searchTerm);
            const contentMatch = (note.content || '').toLowerCase().includes(searchTerm);
            
            // 检查关联角色名
            let charMatch = false;
            if (note.linkedCharId && charMap[note.linkedCharId]) {
                charMatch = charMap[note.linkedCharId].includes(searchTerm);
            }
            
            return titleMatch || contentMatch || charMatch;
        });
    }

    // 5. 渲染列表
    noteList.innerHTML = ''; 
    
    if (notes.length === 0) {
        // 空状态 (区分是有数据没搜到，还是完全没数据)
        const emptyText = searchTerm ? `没有找到与 "${searchTerm}" 相关的笔记` : '还没有笔记';
        
        noteList.innerHTML = `
            <div style="display:flex; flex-direction:column; align-items:center; justify-content:center; height:60vh; color:var(--text-secondary-color); opacity:0.6;">
                <svg style="width:60px; height:60px; margin-bottom:20px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                <p style="margin:0; font-size:1em;">${emptyText}</p>
                ${!searchTerm ? '<p style="margin:5px 0 0 0; font-size:0.8em;">点击右上角 "+" 开始记录</p>' : ''}
            </div>
        `;
    } else { 
        notes.forEach(note => { 
            const li = document.createElement('li'); 
            li.dataset.id = note.id; 
            
            // 获取关联角色名用于显示 (可选优化：在列表里显示一个小标签)
            let charTag = '';
            if (note.linkedCharId && charMap[note.linkedCharId]) {
                // 这里用原来的名字显示，而不是toLowerCase后的
                const originalCharName = allChars.find(c => c.id == note.linkedCharId)?.name || '';
                charTag = `<span style="display:inline-block; font-size:0.75em; padding:2px 6px; background:rgba(255,255,255,0.1); border-radius:4px; margin-right:6px; color:var(--primary-color);">🔗 ${originalCharName}</span>`;
            }

            li.innerHTML = `
                <div class="note-title-preview">${charTag}${note.title || '无标题'}</div>
                <div class="note-content-preview">${(note.content || '').substring(0, 50) || '无内容'}</div>
            `; 
            li.addEventListener('click', () => selectNote(note.id)); 
            noteList.appendChild(li); 
        }); 
    } 
    updateActiveNoteInList(); 
}
    /* --- 修复版：选择笔记函数 (带关联回显) --- */
async function selectNote(id) {
    if (window.innerWidth <= 768) {
        const layout = document.querySelector('.notes-layout');
        if (layout) layout.classList.add('editing-mode');
    }

    if (!id) { clearEditor(); return; }

    currentEditingNoteId = id;
    
    const titleInput = document.getElementById('current-note-title-input');
    const contentInput = document.getElementById('note-content-textarea');
    // ✅ 获取下拉框
    const linkSelect = document.getElementById('note-link-char-select');

    // 预处理：清空并禁用
    if (titleInput) { titleInput.value = ''; titleInput.placeholder = "加载中..."; titleInput.disabled = true; }
    if (contentInput) { contentInput.value = ''; contentInput.disabled = true; }
    // ✅ 禁用下拉框
    if (linkSelect) { linkSelect.value = ""; linkSelect.disabled = true; }

    try {
        const note = await getNote(id);
    
        if (note) {
            if (titleInput) { titleInput.value = note.title || ''; titleInput.placeholder = "笔记标题"; titleInput.disabled = false; }
            if (contentInput) { contentInput.value = note.content || ''; contentInput.disabled = false; }
            
            // ✅ 回显关联的角色ID，并启用
            if (linkSelect) {
                // 刷新一下列表，防止有新加的角色没刷出来
                await populateNoteCharSelect(); 
                linkSelect.value = note.linkedCharId || ""; 
                linkSelect.disabled = false; 
            }
        }
    } catch (e) {
        console.error("加载笔记数据出错:", e);
    }

    updateActiveNoteInList();
}
    function updateActiveNoteInList() { document.querySelectorAll('#note-list li').forEach(li => { li.classList.toggle('active', li.dataset.id == currentEditingNoteId); }); }
    async function autoSaveCurrentNote() { 
        if (!currentEditingNoteId) return; 
        clearTimeout(notesSaveTimeout); 
        const saveStatus = document.getElementById('save-notes-status'); 
        saveStatus.textContent = '正在保存...'; 

        notesSaveTimeout = setTimeout(async () => { 
            try { 
                const oldNote = await getNote(currentEditingNoteId); 
                if (!oldNote) return; 
        
                const newTitle = document.getElementById('current-note-title-input').value;
                const newContent = document.getElementById('note-content-textarea').value;
                // ✅ 获取当前选中的角色ID
                const newLinkedCharId = document.getElementById('note-link-char-select').value;
        
                const noteToSave = { 
                     ...oldNote, 
                    title: newTitle,
                    content: newContent,
                    linkedCharId: newLinkedCharId, // ✅ 保存关联ID
                    updatedAt: new Date().toISOString() 
                }; 
        
                await updateNote(noteToSave); 
                saveStatus.textContent = '已保存！'; 
                setTimeout(() => { saveStatus.textContent = ''; }, 2000); 
                await renderNoteList(); 
            } catch(e) { 
                saveStatus.textContent = '保存失败!'; 
                console.error(e); 
            } 
       }, 1000); 
    }
    function openImageViewer(imageUrl) { const imageViewer = document.getElementById('image-viewer'); const fullPreviewImg = document.getElementById('full-preview-img'); if (imageViewer && fullPreviewImg && imageUrl) { fullPreviewImg.src = imageUrl; imageViewer.classList.add('active'); } }
    function closeImageViewer() { const imageViewer = document.getElementById('image-viewer'); if (imageViewer) { imageViewer.classList.remove('active'); setTimeout(() => { document.getElementById('full-preview-img').src = ''; }, 300); } }
    async function handleSearch() {
       const searchTerm = document.getElementById('search-input').value.toLowerCase().trim();
       const allChars = await getAllCharacters();
       if (searchTerm === '') {
           await renderAllCharacterCards(allChars);
       } else {
           const filteredChars = allChars.filter(char => char.name.toLowerCase().includes(searchTerm));
           await renderAllCharacterCards(filteredChars);
       }
    }
// ===== 新增：仪表盘文件夹选择逻辑 =====

// 打开选择弹窗
function openShowcaseSelector() {
    const list = document.getElementById('showcase-folder-list');
    list.innerHTML = '';
    
    folders.forEach(f => {
        const btn = document.createElement('div');
        btn.className = 'capsule-btn';
        if (f === currentShowcaseFolder) btn.classList.add('highlight'); // 高亮当前选中的
        btn.textContent = f;
        btn.onclick = () => changeShowcaseFolder(f);
        list.appendChild(btn);
    });
    
    document.getElementById('showcase-selector-modal').classList.add('active');
}

// 切换并保存设置
async function changeShowcaseFolder(folderName) {
    currentShowcaseFolder = folderName;
    // 保存到数据库，这样刷新后还在
    await setAppData({ key: 'dashboardShowcaseFolder', value: folderName });
    
    document.getElementById('showcase-selector-modal').classList.remove('active');
    
    // 立即刷新仪表盘
    await updateDashboard();
}
    // ==========================================
    // 补充丢失的 clearEditor 函数
    // ==========================================
    function clearEditor() {
        currentEditingNoteId = null;
        const titleInput = document.getElementById('current-note-title-input');
        const contentInput = document.getElementById('note-content-textarea');
        const saveStatus = document.getElementById('save-notes-status');

        // 重置标题输入框
        if (titleInput) {
            titleInput.value = '';
            titleInput.disabled = true; // 禁用，直到选择笔记
            titleInput.placeholder = "笔记标题";
        }
 
        // 重置内容输入框
        if (contentInput) {
            contentInput.value = '';
            contentInput.disabled = true; // 禁用，直到选择笔记
            contentInput.placeholder = "选择或创建一篇笔记以开始编辑...";
        }

        // 清空状态栏
        if (saveStatus) saveStatus.textContent = '';
    
        // 移除列表选中状态
        updateActiveNoteInList();
    }
    // ==========================================
    // 5. 事件监听绑定 (DOMContentLoaded)
    // ==========================================
    // 加载所有角色到笔记关联下拉框
    async function populateNoteCharSelect() {
        const select = document.getElementById('note-link-char-select');
        if (!select) return;
    
        const allChars = await getAllCharacters();
        // 保留第一个“未关联”选项，清空其他的
        select.innerHTML = '<option value="">🔗 未关联</option>';
    
        allChars.forEach(char => {
            const option = document.createElement('option');
            option.value = char.id;
            option.textContent = `${char.name}`;
            select.appendChild(option); 
        });
    }
    function setupEventListeners() {
        document.getElementById('btn-upload').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => handleFileDrop(e.target.files));
        document.getElementById('search-input').addEventListener('input', handleSearch);
        document.getElementById('btn-nope').addEventListener('click', () => dismissCard('left'));
        document.getElementById('btn-like').addEventListener('click', () => dismissCard('right'));
        document.getElementById('card-stack-container').addEventListener('click', (e) => { const thumb = e.target.closest('.card-thumb.current'); if (thumb) { openDetailView(parseInt(thumb.dataset.id)); } });
        document.getElementById('note-search-input').addEventListener('input', renderNoteList);
        // ✅ 新增：下拉框改变时也自动保存
        document.getElementById('note-link-char-select').addEventListener('change', autoSaveCurrentNote);
        const detailView = document.getElementById('card-detail-view');
        const actionMenu = document.getElementById('detail-action-menu');
        const attachmentFileInput = document.getElementById('attachment-file-input');
        
        document.getElementById('detail-close-btn').addEventListener('click', closeDetailView);
        detailView.addEventListener('click', (e) => { if (e.target === detailView) closeDetailView(); });
        document.getElementById('detail-image').addEventListener('click', (e) => { if(e.target.src && !e.target.src.endsWith('null')) openImageViewer(e.target.src); });
        document.getElementById('detail-more-btn').addEventListener('click', (e) => { e.stopPropagation(); actionMenu.classList.toggle('active'); });
        window.addEventListener('click', () => { if (actionMenu.classList.contains('active')) actionMenu.classList.remove('active'); });
        document.getElementById('btn-menu-export-card').addEventListener('click', () => { actionMenu.classList.remove('active'); if (currentDetailCharId) exportCharacterCard(currentDetailCharId); });
        
        document.getElementById('btn-delete-character').addEventListener('click', async () => {
            actionMenu.classList.remove('active');
            if (!currentDetailCharId) return;
            if (confirm('确定要永久删除这张角色卡吗？此操作无法撤销。')) { 
               try { 
                   await deleteCharacterAndAttachments(currentDetailCharId);
                   alert('角色卡已删除。');
                   closeDetailView();
                   await renderAllCharacterCards();
                   await updateDashboard();
               } catch (error) { 
                   console.error('删除操作异常:', error);
                  alert('删除过程中出现错误: ' + (error.message || error)); 
               } 
            }
        });
        
        document.getElementById('btn-menu-add-attachment').addEventListener('click', () => { actionMenu.classList.remove('active'); attachmentFileInput.click(); });
        attachmentFileInput.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (files.length === 0 || !currentDetailCharId) { e.target.value = ''; return; }
            try {
                for (const file of files) { const attachment = { id: `${Date.now()}-${file.name}`, characterId: currentDetailCharId, fileName: file.name, file: file }; await addAttachment(attachment); }
                if (document.getElementById('page-attachments').classList.contains('active')) { await renderAttachmentsPage(currentDetailCharId); } else { await openDetailView(currentDetailCharId); }
                await updateDashboard(); alert(`${files.length} 个附件已成功添加！`);
            } catch (error) { console.error("添加附件失败:", error); alert("添加附件时发生错误。"); } finally { e.target.value = ''; }
        });
        
        document.getElementById('attachments-summary-section').addEventListener('click', async () => { if (!currentDetailCharId) return; await renderAttachmentsPage(currentDetailCharId); detailView.classList.remove('active'); showPage('page-attachments'); });
        document.getElementById('btn-back-to-detail').addEventListener('click', async () => { if (!currentDetailCharId) return; showPage('page-library'); await openDetailView(currentDetailCharId); });
        document.getElementById('image-viewer').addEventListener('click', (e) => { if (e.target.id === 'image-viewer') closeImageViewer(); });
        document.querySelector('.image-viewer-close').addEventListener('click', closeImageViewer);
        
        document.querySelectorAll('.nav-item').forEach(item => { item.addEventListener('click', function(e) { e.preventDefault(); showPage(this.dataset.target); document.querySelectorAll('.nav-item').forEach(nav => nav.classList.remove('active')); this.classList.add('active'); }); });
        
        document.getElementById('btn-new-note').addEventListener('click', () => { document.getElementById('new-note-title-input').value = ''; document.getElementById('new-note-content-textarea').value = ''; showPage('page-new-note'); });
        document.getElementById('btn-cancel-new-note').addEventListener('click', () => showPage('page-notes'));
        document.getElementById('btn-save-new-note').addEventListener('click', async () => { const title = document.getElementById('new-note-title-input').value.trim(); if (!title) { alert('笔记标题不能为空！'); return; } const content = document.getElementById('new-note-content-textarea').value; const newId = await addNote({ title, content, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() }); await renderNoteList(); selectNote(newId); showPage('page-notes'); });
        // 修复后的删除逻辑：先切页面，再删数据，杜绝空白页
        document.getElementById('btn-delete-note').addEventListener('click', async () => {
            if (!currentEditingNoteId) return;
            if (confirm('确定要删除这篇笔记吗？')) {
               const idToDelete = currentEditingNoteId;

               // 1. ✅ 核心修复：立刻切回列表视图 (手机端)
               // 这样用户马上就能看到列表，不会盯着空白的编辑器发呆
               document.querySelector('.notes-layout').classList.remove('editing-mode');

               // 2. 清空编辑器状态
               clearEditor();

               // 3. 执行删除和刷新
               try {
                   await deleteNote(idToDelete);
                   await renderNoteList();
               } catch (e) {
                   console.error("删除失败:", e);
                   alert("删除出错");
               }
            }
        });
        document.getElementById('note-content-textarea').addEventListener('input', autoSaveCurrentNote);
        // 让标题输入框也触发自动保存
        document.getElementById('current-note-title-input').addEventListener('input', autoSaveCurrentNote);
        document.getElementById('btn-back-to-list').addEventListener('click', () => document.querySelector('.notes-layout').classList.remove('editing-mode'));
        document.querySelector('.nav-item[data-target="page-notes"]').addEventListener('click', renderNoteList);
        
        document.getElementById('btn-export-all').addEventListener('click', exportAllCharactersAsZip);
        
        const importInput = document.getElementById('import-zip-input');
        document.getElementById('btn-import-all').addEventListener('click', () => { importInput.value = ''; importInput.click(); });
        importInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            if (confirm(`准备从 "${file.name}" 恢复数据。\n建议在导入前先清空现有数据以避免重复，是否继续？`)) { importFromBackup(file); }
        });
        
        document.getElementById('btn-clear-all').addEventListener('click', async () => {
            if (confirm('警告：您确定要清除所有数据吗？\n此操作将删除所有角色卡、附件和笔记，且无法撤销！')) {
                try { await clearAllData(); alert('所有数据已成功清除。页面即将刷新。'); location.reload(); } catch (error) { console.error('清除数据失败:', error); alert('清除数据时发生错误。'); }
            }
        });

        // 绑定抽卡相关事件
        document.getElementById('btn-summon').addEventListener('click', performSummon);
        document.getElementById('btn-gacha-again').addEventListener('click', () => {
            const gachaCard = document.getElementById('gacha-card');
            const gachaActions = document.getElementById('gacha-actions');
            gachaActions.classList.remove('show');
            gachaCard.classList.remove('flipped');
            setTimeout(() => { resetGacha(); }, 400);
        });
        document.getElementById('btn-gacha-detail').addEventListener('click', async () => {
            if (currentGachaCharId) { await openDetailView(currentGachaCharId); }
        });
        document.querySelector('.nav-item[data-target="page-gacha"]').addEventListener('click', resetGacha);
        // 初始化 JSON 导入功能
        // ==========================================
        // 修复：GitHub 云端备份按钮事件绑定
        // ==========================================

        // 1. 绑定仪表盘上的“云端备份”按钮 -> 打开弹窗
        const btnBackupGithub = document.getElementById('btn-backup-github');
        if (btnBackupGithub) {
            btnBackupGithub.addEventListener('click', () => {
            document.getElementById('github-backup-modal').classList.add('active');
        });  
    }
 
       // 2. 绑定弹窗内的“取消”按钮 -> 关闭弹窗
      const btnCancelGithub = document.getElementById('btn-cancel-github-backup');
      if (btnCancelGithub) {
          btnCancelGithub.addEventListener('click', () => {
              document.getElementById('github-backup-modal').classList.remove('active');
              // 重置状态文字
              document.getElementById('github-status-message').textContent = '';
          });
      }

      // 3. 绑定弹窗内的“确认备份”按钮 -> 执行备份逻辑
      const btnConfirmGithub = document.getElementById('btn-confirm-github-backup');
      if (btnConfirmGithub) {
         btnConfirmGithub.addEventListener('click', backupToGitHub);
      }
      //setupJsonImport();//
    }
    // ==========================================
    // 6. 初始化入口
    // ==========================================
    window.onload = async () => {
    try {
        await initDB();
        await loadFolders(); // 先加载文件夹列表
        
        // 读取仪表盘设置
        const savedShowcase = await getAppData('dashboardShowcaseFolder');
        if (savedShowcase && savedShowcase.value) {
            // 检查文件夹是否还存在
            if (folders.includes(savedShowcase.value)) {
                currentShowcaseFolder = savedShowcase.value;
            }
        }

        if (!currentFolder) currentFolder = '默认文件夹';
        await renderAllCharacterCards();
        setupEventListeners();
        await updateDashboard(); 
        // ✅ 新增这一行：初始化笔记页面的角色列表
        await populateNoteCharSelect(); 

        
        const oldNotesData = await getAppData('quickNotes');
        if (oldNotesData && oldNotesData.value) {
            await addNote({ title: '我的旧笔记 (来自旧版)', content: oldNotesData.value, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() });
            await setAppData({ key: 'quickNotes', value: '' });
        }
        renderNoteList();
        clearEditor();
    } catch (error) {
        console.error("初始化应用失败:", error);
        alert("应用初始化遇到问题，尝试以安全模式加载...");
        currentFolder = '默认文件夹';
        await renderAllCharacterCards(); 
    }
};
    
</script>
</body>
</html>